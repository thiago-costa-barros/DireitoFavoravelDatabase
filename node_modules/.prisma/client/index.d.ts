
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ExternalWebhookHotmartReceiver
 * 
 */
export type ExternalWebhookHotmartReceiver = $Result.DefaultSelection<Prisma.$ExternalWebhookHotmartReceiverPayload>
/**
 * Model HotmartOrderNote
 * 
 */
export type HotmartOrderNote = $Result.DefaultSelection<Prisma.$HotmartOrderNotePayload>
/**
 * Model HotmartProduct
 * 
 */
export type HotmartProduct = $Result.DefaultSelection<Prisma.$HotmartProductPayload>
/**
 * Model HotmartAffiliates
 * 
 */
export type HotmartAffiliates = $Result.DefaultSelection<Prisma.$HotmartAffiliatesPayload>
/**
 * Model HotmartBuyer
 * 
 */
export type HotmartBuyer = $Result.DefaultSelection<Prisma.$HotmartBuyerPayload>
/**
 * Model HotmartCommissions
 * 
 */
export type HotmartCommissions = $Result.DefaultSelection<Prisma.$HotmartCommissionsPayload>
/**
 * Model HotmartPurchase
 * 
 */
export type HotmartPurchase = $Result.DefaultSelection<Prisma.$HotmartPurchasePayload>
/**
 * Model HotmartPaymentInfos
 * 
 */
export type HotmartPaymentInfos = $Result.DefaultSelection<Prisma.$HotmartPaymentInfosPayload>
/**
 * Model HotmartSubscription
 * 
 */
export type HotmartSubscription = $Result.DefaultSelection<Prisma.$HotmartSubscriptionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ExternalWebhookHotmartReceivers
 * const externalWebhookHotmartReceivers = await prisma.externalWebhookHotmartReceiver.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ExternalWebhookHotmartReceivers
   * const externalWebhookHotmartReceivers = await prisma.externalWebhookHotmartReceiver.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.externalWebhookHotmartReceiver`: Exposes CRUD operations for the **ExternalWebhookHotmartReceiver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalWebhookHotmartReceivers
    * const externalWebhookHotmartReceivers = await prisma.externalWebhookHotmartReceiver.findMany()
    * ```
    */
  get externalWebhookHotmartReceiver(): Prisma.ExternalWebhookHotmartReceiverDelegate<ExtArgs>;

  /**
   * `prisma.hotmartOrderNote`: Exposes CRUD operations for the **HotmartOrderNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartOrderNotes
    * const hotmartOrderNotes = await prisma.hotmartOrderNote.findMany()
    * ```
    */
  get hotmartOrderNote(): Prisma.HotmartOrderNoteDelegate<ExtArgs>;

  /**
   * `prisma.hotmartProduct`: Exposes CRUD operations for the **HotmartProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartProducts
    * const hotmartProducts = await prisma.hotmartProduct.findMany()
    * ```
    */
  get hotmartProduct(): Prisma.HotmartProductDelegate<ExtArgs>;

  /**
   * `prisma.hotmartAffiliates`: Exposes CRUD operations for the **HotmartAffiliates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartAffiliates
    * const hotmartAffiliates = await prisma.hotmartAffiliates.findMany()
    * ```
    */
  get hotmartAffiliates(): Prisma.HotmartAffiliatesDelegate<ExtArgs>;

  /**
   * `prisma.hotmartBuyer`: Exposes CRUD operations for the **HotmartBuyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartBuyers
    * const hotmartBuyers = await prisma.hotmartBuyer.findMany()
    * ```
    */
  get hotmartBuyer(): Prisma.HotmartBuyerDelegate<ExtArgs>;

  /**
   * `prisma.hotmartCommissions`: Exposes CRUD operations for the **HotmartCommissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartCommissions
    * const hotmartCommissions = await prisma.hotmartCommissions.findMany()
    * ```
    */
  get hotmartCommissions(): Prisma.HotmartCommissionsDelegate<ExtArgs>;

  /**
   * `prisma.hotmartPurchase`: Exposes CRUD operations for the **HotmartPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartPurchases
    * const hotmartPurchases = await prisma.hotmartPurchase.findMany()
    * ```
    */
  get hotmartPurchase(): Prisma.HotmartPurchaseDelegate<ExtArgs>;

  /**
   * `prisma.hotmartPaymentInfos`: Exposes CRUD operations for the **HotmartPaymentInfos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartPaymentInfos
    * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findMany()
    * ```
    */
  get hotmartPaymentInfos(): Prisma.HotmartPaymentInfosDelegate<ExtArgs>;

  /**
   * `prisma.hotmartSubscription`: Exposes CRUD operations for the **HotmartSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotmartSubscriptions
    * const hotmartSubscriptions = await prisma.hotmartSubscription.findMany()
    * ```
    */
  get hotmartSubscription(): Prisma.HotmartSubscriptionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ExternalWebhookHotmartReceiver: 'ExternalWebhookHotmartReceiver',
    HotmartOrderNote: 'HotmartOrderNote',
    HotmartProduct: 'HotmartProduct',
    HotmartAffiliates: 'HotmartAffiliates',
    HotmartBuyer: 'HotmartBuyer',
    HotmartCommissions: 'HotmartCommissions',
    HotmartPurchase: 'HotmartPurchase',
    HotmartPaymentInfos: 'HotmartPaymentInfos',
    HotmartSubscription: 'HotmartSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "externalWebhookHotmartReceiver" | "hotmartOrderNote" | "hotmartProduct" | "hotmartAffiliates" | "hotmartBuyer" | "hotmartCommissions" | "hotmartPurchase" | "hotmartPaymentInfos" | "hotmartSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ExternalWebhookHotmartReceiver: {
        payload: Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>
        fields: Prisma.ExternalWebhookHotmartReceiverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalWebhookHotmartReceiverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalWebhookHotmartReceiverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          findFirst: {
            args: Prisma.ExternalWebhookHotmartReceiverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalWebhookHotmartReceiverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          findMany: {
            args: Prisma.ExternalWebhookHotmartReceiverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>[]
          }
          create: {
            args: Prisma.ExternalWebhookHotmartReceiverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          createMany: {
            args: Prisma.ExternalWebhookHotmartReceiverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalWebhookHotmartReceiverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>[]
          }
          delete: {
            args: Prisma.ExternalWebhookHotmartReceiverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          update: {
            args: Prisma.ExternalWebhookHotmartReceiverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          deleteMany: {
            args: Prisma.ExternalWebhookHotmartReceiverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalWebhookHotmartReceiverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalWebhookHotmartReceiverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalWebhookHotmartReceiverPayload>
          }
          aggregate: {
            args: Prisma.ExternalWebhookHotmartReceiverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalWebhookHotmartReceiver>
          }
          groupBy: {
            args: Prisma.ExternalWebhookHotmartReceiverGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalWebhookHotmartReceiverGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalWebhookHotmartReceiverCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalWebhookHotmartReceiverCountAggregateOutputType> | number
          }
        }
      }
      HotmartOrderNote: {
        payload: Prisma.$HotmartOrderNotePayload<ExtArgs>
        fields: Prisma.HotmartOrderNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartOrderNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartOrderNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          findFirst: {
            args: Prisma.HotmartOrderNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartOrderNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          findMany: {
            args: Prisma.HotmartOrderNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>[]
          }
          create: {
            args: Prisma.HotmartOrderNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          createMany: {
            args: Prisma.HotmartOrderNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartOrderNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>[]
          }
          delete: {
            args: Prisma.HotmartOrderNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          update: {
            args: Prisma.HotmartOrderNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          deleteMany: {
            args: Prisma.HotmartOrderNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartOrderNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartOrderNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartOrderNotePayload>
          }
          aggregate: {
            args: Prisma.HotmartOrderNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartOrderNote>
          }
          groupBy: {
            args: Prisma.HotmartOrderNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartOrderNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartOrderNoteCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartOrderNoteCountAggregateOutputType> | number
          }
        }
      }
      HotmartProduct: {
        payload: Prisma.$HotmartProductPayload<ExtArgs>
        fields: Prisma.HotmartProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          findFirst: {
            args: Prisma.HotmartProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          findMany: {
            args: Prisma.HotmartProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>[]
          }
          create: {
            args: Prisma.HotmartProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          createMany: {
            args: Prisma.HotmartProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>[]
          }
          delete: {
            args: Prisma.HotmartProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          update: {
            args: Prisma.HotmartProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          deleteMany: {
            args: Prisma.HotmartProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartProductPayload>
          }
          aggregate: {
            args: Prisma.HotmartProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartProduct>
          }
          groupBy: {
            args: Prisma.HotmartProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartProductCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartProductCountAggregateOutputType> | number
          }
        }
      }
      HotmartAffiliates: {
        payload: Prisma.$HotmartAffiliatesPayload<ExtArgs>
        fields: Prisma.HotmartAffiliatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartAffiliatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartAffiliatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          findFirst: {
            args: Prisma.HotmartAffiliatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartAffiliatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          findMany: {
            args: Prisma.HotmartAffiliatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>[]
          }
          create: {
            args: Prisma.HotmartAffiliatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          createMany: {
            args: Prisma.HotmartAffiliatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartAffiliatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>[]
          }
          delete: {
            args: Prisma.HotmartAffiliatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          update: {
            args: Prisma.HotmartAffiliatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          deleteMany: {
            args: Prisma.HotmartAffiliatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartAffiliatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartAffiliatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartAffiliatesPayload>
          }
          aggregate: {
            args: Prisma.HotmartAffiliatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartAffiliates>
          }
          groupBy: {
            args: Prisma.HotmartAffiliatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartAffiliatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartAffiliatesCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartAffiliatesCountAggregateOutputType> | number
          }
        }
      }
      HotmartBuyer: {
        payload: Prisma.$HotmartBuyerPayload<ExtArgs>
        fields: Prisma.HotmartBuyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartBuyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartBuyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          findFirst: {
            args: Prisma.HotmartBuyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartBuyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          findMany: {
            args: Prisma.HotmartBuyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>[]
          }
          create: {
            args: Prisma.HotmartBuyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          createMany: {
            args: Prisma.HotmartBuyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartBuyerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>[]
          }
          delete: {
            args: Prisma.HotmartBuyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          update: {
            args: Prisma.HotmartBuyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          deleteMany: {
            args: Prisma.HotmartBuyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartBuyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartBuyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartBuyerPayload>
          }
          aggregate: {
            args: Prisma.HotmartBuyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartBuyer>
          }
          groupBy: {
            args: Prisma.HotmartBuyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartBuyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartBuyerCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartBuyerCountAggregateOutputType> | number
          }
        }
      }
      HotmartCommissions: {
        payload: Prisma.$HotmartCommissionsPayload<ExtArgs>
        fields: Prisma.HotmartCommissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartCommissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartCommissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          findFirst: {
            args: Prisma.HotmartCommissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartCommissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          findMany: {
            args: Prisma.HotmartCommissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>[]
          }
          create: {
            args: Prisma.HotmartCommissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          createMany: {
            args: Prisma.HotmartCommissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartCommissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>[]
          }
          delete: {
            args: Prisma.HotmartCommissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          update: {
            args: Prisma.HotmartCommissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          deleteMany: {
            args: Prisma.HotmartCommissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartCommissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartCommissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartCommissionsPayload>
          }
          aggregate: {
            args: Prisma.HotmartCommissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartCommissions>
          }
          groupBy: {
            args: Prisma.HotmartCommissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartCommissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartCommissionsCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartCommissionsCountAggregateOutputType> | number
          }
        }
      }
      HotmartPurchase: {
        payload: Prisma.$HotmartPurchasePayload<ExtArgs>
        fields: Prisma.HotmartPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          findFirst: {
            args: Prisma.HotmartPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          findMany: {
            args: Prisma.HotmartPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>[]
          }
          create: {
            args: Prisma.HotmartPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          createMany: {
            args: Prisma.HotmartPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>[]
          }
          delete: {
            args: Prisma.HotmartPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          update: {
            args: Prisma.HotmartPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          deleteMany: {
            args: Prisma.HotmartPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPurchasePayload>
          }
          aggregate: {
            args: Prisma.HotmartPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartPurchase>
          }
          groupBy: {
            args: Prisma.HotmartPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartPurchaseCountAggregateOutputType> | number
          }
        }
      }
      HotmartPaymentInfos: {
        payload: Prisma.$HotmartPaymentInfosPayload<ExtArgs>
        fields: Prisma.HotmartPaymentInfosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartPaymentInfosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartPaymentInfosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          findFirst: {
            args: Prisma.HotmartPaymentInfosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartPaymentInfosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          findMany: {
            args: Prisma.HotmartPaymentInfosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>[]
          }
          create: {
            args: Prisma.HotmartPaymentInfosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          createMany: {
            args: Prisma.HotmartPaymentInfosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartPaymentInfosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>[]
          }
          delete: {
            args: Prisma.HotmartPaymentInfosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          update: {
            args: Prisma.HotmartPaymentInfosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          deleteMany: {
            args: Prisma.HotmartPaymentInfosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartPaymentInfosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartPaymentInfosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartPaymentInfosPayload>
          }
          aggregate: {
            args: Prisma.HotmartPaymentInfosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartPaymentInfos>
          }
          groupBy: {
            args: Prisma.HotmartPaymentInfosGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartPaymentInfosGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartPaymentInfosCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartPaymentInfosCountAggregateOutputType> | number
          }
        }
      }
      HotmartSubscription: {
        payload: Prisma.$HotmartSubscriptionPayload<ExtArgs>
        fields: Prisma.HotmartSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotmartSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotmartSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.HotmartSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotmartSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          findMany: {
            args: Prisma.HotmartSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>[]
          }
          create: {
            args: Prisma.HotmartSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          createMany: {
            args: Prisma.HotmartSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotmartSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.HotmartSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          update: {
            args: Prisma.HotmartSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.HotmartSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotmartSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotmartSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotmartSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.HotmartSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotmartSubscription>
          }
          groupBy: {
            args: Prisma.HotmartSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotmartSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotmartSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<HotmartSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ExternalWebhookHotmartReceiverCountOutputType
   */

  export type ExternalWebhookHotmartReceiverCountOutputType = {
    HotmartOrderNote: number
  }

  export type ExternalWebhookHotmartReceiverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | ExternalWebhookHotmartReceiverCountOutputTypeCountHotmartOrderNoteArgs
  }

  // Custom InputTypes
  /**
   * ExternalWebhookHotmartReceiverCountOutputType without action
   */
  export type ExternalWebhookHotmartReceiverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiverCountOutputType
     */
    select?: ExternalWebhookHotmartReceiverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExternalWebhookHotmartReceiverCountOutputType without action
   */
  export type ExternalWebhookHotmartReceiverCountOutputTypeCountHotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
  }


  /**
   * Count Type HotmartOrderNoteCountOutputType
   */

  export type HotmartOrderNoteCountOutputType = {
    hotmartAffiliates: number
  }

  export type HotmartOrderNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotmartAffiliates?: boolean | HotmartOrderNoteCountOutputTypeCountHotmartAffiliatesArgs
  }

  // Custom InputTypes
  /**
   * HotmartOrderNoteCountOutputType without action
   */
  export type HotmartOrderNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNoteCountOutputType
     */
    select?: HotmartOrderNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotmartOrderNoteCountOutputType without action
   */
  export type HotmartOrderNoteCountOutputTypeCountHotmartAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartAffiliatesWhereInput
  }


  /**
   * Count Type HotmartProductCountOutputType
   */

  export type HotmartProductCountOutputType = {
    HotmartOrderNote: number
  }

  export type HotmartProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartProductCountOutputTypeCountHotmartOrderNoteArgs
  }

  // Custom InputTypes
  /**
   * HotmartProductCountOutputType without action
   */
  export type HotmartProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProductCountOutputType
     */
    select?: HotmartProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotmartProductCountOutputType without action
   */
  export type HotmartProductCountOutputTypeCountHotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
  }


  /**
   * Count Type HotmartBuyerCountOutputType
   */

  export type HotmartBuyerCountOutputType = {
    HotmartOrderNote: number
  }

  export type HotmartBuyerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartBuyerCountOutputTypeCountHotmartOrderNoteArgs
  }

  // Custom InputTypes
  /**
   * HotmartBuyerCountOutputType without action
   */
  export type HotmartBuyerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyerCountOutputType
     */
    select?: HotmartBuyerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotmartBuyerCountOutputType without action
   */
  export type HotmartBuyerCountOutputTypeCountHotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
  }


  /**
   * Count Type HotmartPurchaseCountOutputType
   */

  export type HotmartPurchaseCountOutputType = {
    hotmartPaymentInfos: number
    hotmartCommissions: number
    HotmartOrderNote: number
  }

  export type HotmartPurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotmartPaymentInfos?: boolean | HotmartPurchaseCountOutputTypeCountHotmartPaymentInfosArgs
    hotmartCommissions?: boolean | HotmartPurchaseCountOutputTypeCountHotmartCommissionsArgs
    HotmartOrderNote?: boolean | HotmartPurchaseCountOutputTypeCountHotmartOrderNoteArgs
  }

  // Custom InputTypes
  /**
   * HotmartPurchaseCountOutputType without action
   */
  export type HotmartPurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchaseCountOutputType
     */
    select?: HotmartPurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotmartPurchaseCountOutputType without action
   */
  export type HotmartPurchaseCountOutputTypeCountHotmartPaymentInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartPaymentInfosWhereInput
  }

  /**
   * HotmartPurchaseCountOutputType without action
   */
  export type HotmartPurchaseCountOutputTypeCountHotmartCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartCommissionsWhereInput
  }

  /**
   * HotmartPurchaseCountOutputType without action
   */
  export type HotmartPurchaseCountOutputTypeCountHotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
  }


  /**
   * Count Type HotmartSubscriptionCountOutputType
   */

  export type HotmartSubscriptionCountOutputType = {
    HotmartOrderNote: number
  }

  export type HotmartSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartSubscriptionCountOutputTypeCountHotmartOrderNoteArgs
  }

  // Custom InputTypes
  /**
   * HotmartSubscriptionCountOutputType without action
   */
  export type HotmartSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscriptionCountOutputType
     */
    select?: HotmartSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotmartSubscriptionCountOutputType without action
   */
  export type HotmartSubscriptionCountOutputTypeCountHotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ExternalWebhookHotmartReceiver
   */

  export type AggregateExternalWebhookHotmartReceiver = {
    _count: ExternalWebhookHotmartReceiverCountAggregateOutputType | null
    _avg: ExternalWebhookHotmartReceiverAvgAggregateOutputType | null
    _sum: ExternalWebhookHotmartReceiverSumAggregateOutputType | null
    _min: ExternalWebhookHotmartReceiverMinAggregateOutputType | null
    _max: ExternalWebhookHotmartReceiverMaxAggregateOutputType | null
  }

  export type ExternalWebhookHotmartReceiverAvgAggregateOutputType = {
    id: number | null
  }

  export type ExternalWebhookHotmartReceiverSumAggregateOutputType = {
    id: number | null
  }

  export type ExternalWebhookHotmartReceiverMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    requestId: string | null
    eventDate: Date | null
    eventName: string | null
    version: string | null
  }

  export type ExternalWebhookHotmartReceiverMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    requestId: string | null
    eventDate: Date | null
    eventName: string | null
    version: string | null
  }

  export type ExternalWebhookHotmartReceiverCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    requestId: number
    eventDate: number
    eventName: number
    version: number
    payload: number
    _all: number
  }


  export type ExternalWebhookHotmartReceiverAvgAggregateInputType = {
    id?: true
  }

  export type ExternalWebhookHotmartReceiverSumAggregateInputType = {
    id?: true
  }

  export type ExternalWebhookHotmartReceiverMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    requestId?: true
    eventDate?: true
    eventName?: true
    version?: true
  }

  export type ExternalWebhookHotmartReceiverMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    requestId?: true
    eventDate?: true
    eventName?: true
    version?: true
  }

  export type ExternalWebhookHotmartReceiverCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    requestId?: true
    eventDate?: true
    eventName?: true
    version?: true
    payload?: true
    _all?: true
  }

  export type ExternalWebhookHotmartReceiverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalWebhookHotmartReceiver to aggregate.
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalWebhookHotmartReceivers to fetch.
     */
    orderBy?: ExternalWebhookHotmartReceiverOrderByWithRelationInput | ExternalWebhookHotmartReceiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalWebhookHotmartReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalWebhookHotmartReceivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalWebhookHotmartReceivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalWebhookHotmartReceivers
    **/
    _count?: true | ExternalWebhookHotmartReceiverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalWebhookHotmartReceiverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalWebhookHotmartReceiverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalWebhookHotmartReceiverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalWebhookHotmartReceiverMaxAggregateInputType
  }

  export type GetExternalWebhookHotmartReceiverAggregateType<T extends ExternalWebhookHotmartReceiverAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalWebhookHotmartReceiver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalWebhookHotmartReceiver[P]>
      : GetScalarType<T[P], AggregateExternalWebhookHotmartReceiver[P]>
  }




  export type ExternalWebhookHotmartReceiverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalWebhookHotmartReceiverWhereInput
    orderBy?: ExternalWebhookHotmartReceiverOrderByWithAggregationInput | ExternalWebhookHotmartReceiverOrderByWithAggregationInput[]
    by: ExternalWebhookHotmartReceiverScalarFieldEnum[] | ExternalWebhookHotmartReceiverScalarFieldEnum
    having?: ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalWebhookHotmartReceiverCountAggregateInputType | true
    _avg?: ExternalWebhookHotmartReceiverAvgAggregateInputType
    _sum?: ExternalWebhookHotmartReceiverSumAggregateInputType
    _min?: ExternalWebhookHotmartReceiverMinAggregateInputType
    _max?: ExternalWebhookHotmartReceiverMaxAggregateInputType
  }

  export type ExternalWebhookHotmartReceiverGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    requestId: string
    eventDate: Date
    eventName: string
    version: string
    payload: JsonValue
    _count: ExternalWebhookHotmartReceiverCountAggregateOutputType | null
    _avg: ExternalWebhookHotmartReceiverAvgAggregateOutputType | null
    _sum: ExternalWebhookHotmartReceiverSumAggregateOutputType | null
    _min: ExternalWebhookHotmartReceiverMinAggregateOutputType | null
    _max: ExternalWebhookHotmartReceiverMaxAggregateOutputType | null
  }

  type GetExternalWebhookHotmartReceiverGroupByPayload<T extends ExternalWebhookHotmartReceiverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalWebhookHotmartReceiverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalWebhookHotmartReceiverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalWebhookHotmartReceiverGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalWebhookHotmartReceiverGroupByOutputType[P]>
        }
      >
    >


  export type ExternalWebhookHotmartReceiverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    requestId?: boolean
    eventDate?: boolean
    eventName?: boolean
    version?: boolean
    payload?: boolean
    HotmartOrderNote?: boolean | ExternalWebhookHotmartReceiver$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | ExternalWebhookHotmartReceiverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalWebhookHotmartReceiver"]>

  export type ExternalWebhookHotmartReceiverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    requestId?: boolean
    eventDate?: boolean
    eventName?: boolean
    version?: boolean
    payload?: boolean
  }, ExtArgs["result"]["externalWebhookHotmartReceiver"]>

  export type ExternalWebhookHotmartReceiverSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    requestId?: boolean
    eventDate?: boolean
    eventName?: boolean
    version?: boolean
    payload?: boolean
  }

  export type ExternalWebhookHotmartReceiverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | ExternalWebhookHotmartReceiver$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | ExternalWebhookHotmartReceiverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExternalWebhookHotmartReceiverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExternalWebhookHotmartReceiverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalWebhookHotmartReceiver"
    objects: {
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      requestId: string
      eventDate: Date
      eventName: string
      version: string
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["externalWebhookHotmartReceiver"]>
    composites: {}
  }

  type ExternalWebhookHotmartReceiverGetPayload<S extends boolean | null | undefined | ExternalWebhookHotmartReceiverDefaultArgs> = $Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload, S>

  type ExternalWebhookHotmartReceiverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExternalWebhookHotmartReceiverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExternalWebhookHotmartReceiverCountAggregateInputType | true
    }

  export interface ExternalWebhookHotmartReceiverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalWebhookHotmartReceiver'], meta: { name: 'ExternalWebhookHotmartReceiver' } }
    /**
     * Find zero or one ExternalWebhookHotmartReceiver that matches the filter.
     * @param {ExternalWebhookHotmartReceiverFindUniqueArgs} args - Arguments to find a ExternalWebhookHotmartReceiver
     * @example
     * // Get one ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalWebhookHotmartReceiverFindUniqueArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverFindUniqueArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExternalWebhookHotmartReceiver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExternalWebhookHotmartReceiverFindUniqueOrThrowArgs} args - Arguments to find a ExternalWebhookHotmartReceiver
     * @example
     * // Get one ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalWebhookHotmartReceiverFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExternalWebhookHotmartReceiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverFindFirstArgs} args - Arguments to find a ExternalWebhookHotmartReceiver
     * @example
     * // Get one ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalWebhookHotmartReceiverFindFirstArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverFindFirstArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExternalWebhookHotmartReceiver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverFindFirstOrThrowArgs} args - Arguments to find a ExternalWebhookHotmartReceiver
     * @example
     * // Get one ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalWebhookHotmartReceiverFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExternalWebhookHotmartReceivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalWebhookHotmartReceivers
     * const externalWebhookHotmartReceivers = await prisma.externalWebhookHotmartReceiver.findMany()
     * 
     * // Get first 10 ExternalWebhookHotmartReceivers
     * const externalWebhookHotmartReceivers = await prisma.externalWebhookHotmartReceiver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalWebhookHotmartReceiverWithIdOnly = await prisma.externalWebhookHotmartReceiver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalWebhookHotmartReceiverFindManyArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExternalWebhookHotmartReceiver.
     * @param {ExternalWebhookHotmartReceiverCreateArgs} args - Arguments to create a ExternalWebhookHotmartReceiver.
     * @example
     * // Create one ExternalWebhookHotmartReceiver
     * const ExternalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.create({
     *   data: {
     *     // ... data to create a ExternalWebhookHotmartReceiver
     *   }
     * })
     * 
     */
    create<T extends ExternalWebhookHotmartReceiverCreateArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverCreateArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExternalWebhookHotmartReceivers.
     * @param {ExternalWebhookHotmartReceiverCreateManyArgs} args - Arguments to create many ExternalWebhookHotmartReceivers.
     * @example
     * // Create many ExternalWebhookHotmartReceivers
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalWebhookHotmartReceiverCreateManyArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalWebhookHotmartReceivers and returns the data saved in the database.
     * @param {ExternalWebhookHotmartReceiverCreateManyAndReturnArgs} args - Arguments to create many ExternalWebhookHotmartReceivers.
     * @example
     * // Create many ExternalWebhookHotmartReceivers
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalWebhookHotmartReceivers and only return the `id`
     * const externalWebhookHotmartReceiverWithIdOnly = await prisma.externalWebhookHotmartReceiver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalWebhookHotmartReceiverCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExternalWebhookHotmartReceiver.
     * @param {ExternalWebhookHotmartReceiverDeleteArgs} args - Arguments to delete one ExternalWebhookHotmartReceiver.
     * @example
     * // Delete one ExternalWebhookHotmartReceiver
     * const ExternalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.delete({
     *   where: {
     *     // ... filter to delete one ExternalWebhookHotmartReceiver
     *   }
     * })
     * 
     */
    delete<T extends ExternalWebhookHotmartReceiverDeleteArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverDeleteArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExternalWebhookHotmartReceiver.
     * @param {ExternalWebhookHotmartReceiverUpdateArgs} args - Arguments to update one ExternalWebhookHotmartReceiver.
     * @example
     * // Update one ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalWebhookHotmartReceiverUpdateArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverUpdateArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExternalWebhookHotmartReceivers.
     * @param {ExternalWebhookHotmartReceiverDeleteManyArgs} args - Arguments to filter ExternalWebhookHotmartReceivers to delete.
     * @example
     * // Delete a few ExternalWebhookHotmartReceivers
     * const { count } = await prisma.externalWebhookHotmartReceiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalWebhookHotmartReceiverDeleteManyArgs>(args?: SelectSubset<T, ExternalWebhookHotmartReceiverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalWebhookHotmartReceivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalWebhookHotmartReceivers
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalWebhookHotmartReceiverUpdateManyArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalWebhookHotmartReceiver.
     * @param {ExternalWebhookHotmartReceiverUpsertArgs} args - Arguments to update or create a ExternalWebhookHotmartReceiver.
     * @example
     * // Update or create a ExternalWebhookHotmartReceiver
     * const externalWebhookHotmartReceiver = await prisma.externalWebhookHotmartReceiver.upsert({
     *   create: {
     *     // ... data to create a ExternalWebhookHotmartReceiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalWebhookHotmartReceiver we want to update
     *   }
     * })
     */
    upsert<T extends ExternalWebhookHotmartReceiverUpsertArgs>(args: SelectSubset<T, ExternalWebhookHotmartReceiverUpsertArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExternalWebhookHotmartReceivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverCountArgs} args - Arguments to filter ExternalWebhookHotmartReceivers to count.
     * @example
     * // Count the number of ExternalWebhookHotmartReceivers
     * const count = await prisma.externalWebhookHotmartReceiver.count({
     *   where: {
     *     // ... the filter for the ExternalWebhookHotmartReceivers we want to count
     *   }
     * })
    **/
    count<T extends ExternalWebhookHotmartReceiverCountArgs>(
      args?: Subset<T, ExternalWebhookHotmartReceiverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalWebhookHotmartReceiverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalWebhookHotmartReceiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalWebhookHotmartReceiverAggregateArgs>(args: Subset<T, ExternalWebhookHotmartReceiverAggregateArgs>): Prisma.PrismaPromise<GetExternalWebhookHotmartReceiverAggregateType<T>>

    /**
     * Group by ExternalWebhookHotmartReceiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalWebhookHotmartReceiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalWebhookHotmartReceiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalWebhookHotmartReceiverGroupByArgs['orderBy'] }
        : { orderBy?: ExternalWebhookHotmartReceiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalWebhookHotmartReceiverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalWebhookHotmartReceiverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalWebhookHotmartReceiver model
   */
  readonly fields: ExternalWebhookHotmartReceiverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalWebhookHotmartReceiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalWebhookHotmartReceiverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartOrderNote<T extends ExternalWebhookHotmartReceiver$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, ExternalWebhookHotmartReceiver$HotmartOrderNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalWebhookHotmartReceiver model
   */ 
  interface ExternalWebhookHotmartReceiverFieldRefs {
    readonly id: FieldRef<"ExternalWebhookHotmartReceiver", 'Int'>
    readonly creationDate: FieldRef<"ExternalWebhookHotmartReceiver", 'DateTime'>
    readonly updateDate: FieldRef<"ExternalWebhookHotmartReceiver", 'DateTime'>
    readonly deletionDate: FieldRef<"ExternalWebhookHotmartReceiver", 'DateTime'>
    readonly requestId: FieldRef<"ExternalWebhookHotmartReceiver", 'String'>
    readonly eventDate: FieldRef<"ExternalWebhookHotmartReceiver", 'DateTime'>
    readonly eventName: FieldRef<"ExternalWebhookHotmartReceiver", 'String'>
    readonly version: FieldRef<"ExternalWebhookHotmartReceiver", 'String'>
    readonly payload: FieldRef<"ExternalWebhookHotmartReceiver", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ExternalWebhookHotmartReceiver findUnique
   */
  export type ExternalWebhookHotmartReceiverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter, which ExternalWebhookHotmartReceiver to fetch.
     */
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
  }

  /**
   * ExternalWebhookHotmartReceiver findUniqueOrThrow
   */
  export type ExternalWebhookHotmartReceiverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter, which ExternalWebhookHotmartReceiver to fetch.
     */
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
  }

  /**
   * ExternalWebhookHotmartReceiver findFirst
   */
  export type ExternalWebhookHotmartReceiverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter, which ExternalWebhookHotmartReceiver to fetch.
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalWebhookHotmartReceivers to fetch.
     */
    orderBy?: ExternalWebhookHotmartReceiverOrderByWithRelationInput | ExternalWebhookHotmartReceiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalWebhookHotmartReceivers.
     */
    cursor?: ExternalWebhookHotmartReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalWebhookHotmartReceivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalWebhookHotmartReceivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalWebhookHotmartReceivers.
     */
    distinct?: ExternalWebhookHotmartReceiverScalarFieldEnum | ExternalWebhookHotmartReceiverScalarFieldEnum[]
  }

  /**
   * ExternalWebhookHotmartReceiver findFirstOrThrow
   */
  export type ExternalWebhookHotmartReceiverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter, which ExternalWebhookHotmartReceiver to fetch.
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalWebhookHotmartReceivers to fetch.
     */
    orderBy?: ExternalWebhookHotmartReceiverOrderByWithRelationInput | ExternalWebhookHotmartReceiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalWebhookHotmartReceivers.
     */
    cursor?: ExternalWebhookHotmartReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalWebhookHotmartReceivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalWebhookHotmartReceivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalWebhookHotmartReceivers.
     */
    distinct?: ExternalWebhookHotmartReceiverScalarFieldEnum | ExternalWebhookHotmartReceiverScalarFieldEnum[]
  }

  /**
   * ExternalWebhookHotmartReceiver findMany
   */
  export type ExternalWebhookHotmartReceiverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter, which ExternalWebhookHotmartReceivers to fetch.
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalWebhookHotmartReceivers to fetch.
     */
    orderBy?: ExternalWebhookHotmartReceiverOrderByWithRelationInput | ExternalWebhookHotmartReceiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalWebhookHotmartReceivers.
     */
    cursor?: ExternalWebhookHotmartReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalWebhookHotmartReceivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalWebhookHotmartReceivers.
     */
    skip?: number
    distinct?: ExternalWebhookHotmartReceiverScalarFieldEnum | ExternalWebhookHotmartReceiverScalarFieldEnum[]
  }

  /**
   * ExternalWebhookHotmartReceiver create
   */
  export type ExternalWebhookHotmartReceiverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalWebhookHotmartReceiver.
     */
    data: XOR<ExternalWebhookHotmartReceiverCreateInput, ExternalWebhookHotmartReceiverUncheckedCreateInput>
  }

  /**
   * ExternalWebhookHotmartReceiver createMany
   */
  export type ExternalWebhookHotmartReceiverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalWebhookHotmartReceivers.
     */
    data: ExternalWebhookHotmartReceiverCreateManyInput | ExternalWebhookHotmartReceiverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalWebhookHotmartReceiver createManyAndReturn
   */
  export type ExternalWebhookHotmartReceiverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExternalWebhookHotmartReceivers.
     */
    data: ExternalWebhookHotmartReceiverCreateManyInput | ExternalWebhookHotmartReceiverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalWebhookHotmartReceiver update
   */
  export type ExternalWebhookHotmartReceiverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalWebhookHotmartReceiver.
     */
    data: XOR<ExternalWebhookHotmartReceiverUpdateInput, ExternalWebhookHotmartReceiverUncheckedUpdateInput>
    /**
     * Choose, which ExternalWebhookHotmartReceiver to update.
     */
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
  }

  /**
   * ExternalWebhookHotmartReceiver updateMany
   */
  export type ExternalWebhookHotmartReceiverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalWebhookHotmartReceivers.
     */
    data: XOR<ExternalWebhookHotmartReceiverUpdateManyMutationInput, ExternalWebhookHotmartReceiverUncheckedUpdateManyInput>
    /**
     * Filter which ExternalWebhookHotmartReceivers to update
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
  }

  /**
   * ExternalWebhookHotmartReceiver upsert
   */
  export type ExternalWebhookHotmartReceiverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalWebhookHotmartReceiver to update in case it exists.
     */
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
    /**
     * In case the ExternalWebhookHotmartReceiver found by the `where` argument doesn't exist, create a new ExternalWebhookHotmartReceiver with this data.
     */
    create: XOR<ExternalWebhookHotmartReceiverCreateInput, ExternalWebhookHotmartReceiverUncheckedCreateInput>
    /**
     * In case the ExternalWebhookHotmartReceiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalWebhookHotmartReceiverUpdateInput, ExternalWebhookHotmartReceiverUncheckedUpdateInput>
  }

  /**
   * ExternalWebhookHotmartReceiver delete
   */
  export type ExternalWebhookHotmartReceiverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
    /**
     * Filter which ExternalWebhookHotmartReceiver to delete.
     */
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
  }

  /**
   * ExternalWebhookHotmartReceiver deleteMany
   */
  export type ExternalWebhookHotmartReceiverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalWebhookHotmartReceivers to delete
     */
    where?: ExternalWebhookHotmartReceiverWhereInput
  }

  /**
   * ExternalWebhookHotmartReceiver.HotmartOrderNote
   */
  export type ExternalWebhookHotmartReceiver$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    cursor?: HotmartOrderNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * ExternalWebhookHotmartReceiver without action
   */
  export type ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalWebhookHotmartReceiver
     */
    select?: ExternalWebhookHotmartReceiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalWebhookHotmartReceiverInclude<ExtArgs> | null
  }


  /**
   * Model HotmartOrderNote
   */

  export type AggregateHotmartOrderNote = {
    _count: HotmartOrderNoteCountAggregateOutputType | null
    _avg: HotmartOrderNoteAvgAggregateOutputType | null
    _sum: HotmartOrderNoteSumAggregateOutputType | null
    _min: HotmartOrderNoteMinAggregateOutputType | null
    _max: HotmartOrderNoteMaxAggregateOutputType | null
  }

  export type HotmartOrderNoteAvgAggregateOutputType = {
    id: number | null
    externalWebhookHotmartReceiverId: number | null
    hotmartProductId: number | null
    hotmartBuyerId: number | null
    hotmartPurchaseId: number | null
    hotmartSubscriptionId: number | null
  }

  export type HotmartOrderNoteSumAggregateOutputType = {
    id: number | null
    externalWebhookHotmartReceiverId: number | null
    hotmartProductId: number | null
    hotmartBuyerId: number | null
    hotmartPurchaseId: number | null
    hotmartSubscriptionId: number | null
  }

  export type HotmartOrderNoteMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    externalWebhookHotmartReceiverId: number | null
    hotmartProductId: number | null
    hotmartBuyerId: number | null
    producerName: string | null
    hotmartPurchaseId: number | null
    hotmartSubscriptionId: number | null
  }

  export type HotmartOrderNoteMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    externalWebhookHotmartReceiverId: number | null
    hotmartProductId: number | null
    hotmartBuyerId: number | null
    producerName: string | null
    hotmartPurchaseId: number | null
    hotmartSubscriptionId: number | null
  }

  export type HotmartOrderNoteCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName: number
    hotmartPurchaseId: number
    hotmartSubscriptionId: number
    _all: number
  }


  export type HotmartOrderNoteAvgAggregateInputType = {
    id?: true
    externalWebhookHotmartReceiverId?: true
    hotmartProductId?: true
    hotmartBuyerId?: true
    hotmartPurchaseId?: true
    hotmartSubscriptionId?: true
  }

  export type HotmartOrderNoteSumAggregateInputType = {
    id?: true
    externalWebhookHotmartReceiverId?: true
    hotmartProductId?: true
    hotmartBuyerId?: true
    hotmartPurchaseId?: true
    hotmartSubscriptionId?: true
  }

  export type HotmartOrderNoteMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    externalWebhookHotmartReceiverId?: true
    hotmartProductId?: true
    hotmartBuyerId?: true
    producerName?: true
    hotmartPurchaseId?: true
    hotmartSubscriptionId?: true
  }

  export type HotmartOrderNoteMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    externalWebhookHotmartReceiverId?: true
    hotmartProductId?: true
    hotmartBuyerId?: true
    producerName?: true
    hotmartPurchaseId?: true
    hotmartSubscriptionId?: true
  }

  export type HotmartOrderNoteCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    externalWebhookHotmartReceiverId?: true
    hotmartProductId?: true
    hotmartBuyerId?: true
    producerName?: true
    hotmartPurchaseId?: true
    hotmartSubscriptionId?: true
    _all?: true
  }

  export type HotmartOrderNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartOrderNote to aggregate.
     */
    where?: HotmartOrderNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartOrderNotes to fetch.
     */
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartOrderNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartOrderNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartOrderNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartOrderNotes
    **/
    _count?: true | HotmartOrderNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartOrderNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartOrderNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartOrderNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartOrderNoteMaxAggregateInputType
  }

  export type GetHotmartOrderNoteAggregateType<T extends HotmartOrderNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartOrderNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartOrderNote[P]>
      : GetScalarType<T[P], AggregateHotmartOrderNote[P]>
  }




  export type HotmartOrderNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithAggregationInput | HotmartOrderNoteOrderByWithAggregationInput[]
    by: HotmartOrderNoteScalarFieldEnum[] | HotmartOrderNoteScalarFieldEnum
    having?: HotmartOrderNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartOrderNoteCountAggregateInputType | true
    _avg?: HotmartOrderNoteAvgAggregateInputType
    _sum?: HotmartOrderNoteSumAggregateInputType
    _min?: HotmartOrderNoteMinAggregateInputType
    _max?: HotmartOrderNoteMaxAggregateInputType
  }

  export type HotmartOrderNoteGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId: number | null
    _count: HotmartOrderNoteCountAggregateOutputType | null
    _avg: HotmartOrderNoteAvgAggregateOutputType | null
    _sum: HotmartOrderNoteSumAggregateOutputType | null
    _min: HotmartOrderNoteMinAggregateOutputType | null
    _max: HotmartOrderNoteMaxAggregateOutputType | null
  }

  type GetHotmartOrderNoteGroupByPayload<T extends HotmartOrderNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartOrderNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartOrderNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartOrderNoteGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartOrderNoteGroupByOutputType[P]>
        }
      >
    >


  export type HotmartOrderNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    externalWebhookHotmartReceiverId?: boolean
    hotmartProductId?: boolean
    hotmartBuyerId?: boolean
    producerName?: boolean
    hotmartPurchaseId?: boolean
    hotmartSubscriptionId?: boolean
    externalWebhookHotmartReceiver?: boolean | ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>
    hotmartProduct?: boolean | HotmartProductDefaultArgs<ExtArgs>
    hotmartAffiliates?: boolean | HotmartOrderNote$hotmartAffiliatesArgs<ExtArgs>
    hotmartBuyer?: boolean | HotmartBuyerDefaultArgs<ExtArgs>
    hotmartPurchase?: boolean | HotmartPurchaseDefaultArgs<ExtArgs>
    hotmartSubscription?: boolean | HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs>
    _count?: boolean | HotmartOrderNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartOrderNote"]>

  export type HotmartOrderNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    externalWebhookHotmartReceiverId?: boolean
    hotmartProductId?: boolean
    hotmartBuyerId?: boolean
    producerName?: boolean
    hotmartPurchaseId?: boolean
    hotmartSubscriptionId?: boolean
    externalWebhookHotmartReceiver?: boolean | ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>
    hotmartProduct?: boolean | HotmartProductDefaultArgs<ExtArgs>
    hotmartBuyer?: boolean | HotmartBuyerDefaultArgs<ExtArgs>
    hotmartPurchase?: boolean | HotmartPurchaseDefaultArgs<ExtArgs>
    hotmartSubscription?: boolean | HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartOrderNote"]>

  export type HotmartOrderNoteSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    externalWebhookHotmartReceiverId?: boolean
    hotmartProductId?: boolean
    hotmartBuyerId?: boolean
    producerName?: boolean
    hotmartPurchaseId?: boolean
    hotmartSubscriptionId?: boolean
  }

  export type HotmartOrderNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externalWebhookHotmartReceiver?: boolean | ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>
    hotmartProduct?: boolean | HotmartProductDefaultArgs<ExtArgs>
    hotmartAffiliates?: boolean | HotmartOrderNote$hotmartAffiliatesArgs<ExtArgs>
    hotmartBuyer?: boolean | HotmartBuyerDefaultArgs<ExtArgs>
    hotmartPurchase?: boolean | HotmartPurchaseDefaultArgs<ExtArgs>
    hotmartSubscription?: boolean | HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs>
    _count?: boolean | HotmartOrderNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotmartOrderNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externalWebhookHotmartReceiver?: boolean | ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>
    hotmartProduct?: boolean | HotmartProductDefaultArgs<ExtArgs>
    hotmartBuyer?: boolean | HotmartBuyerDefaultArgs<ExtArgs>
    hotmartPurchase?: boolean | HotmartPurchaseDefaultArgs<ExtArgs>
    hotmartSubscription?: boolean | HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs>
  }

  export type $HotmartOrderNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartOrderNote"
    objects: {
      externalWebhookHotmartReceiver: Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>
      hotmartProduct: Prisma.$HotmartProductPayload<ExtArgs>
      hotmartAffiliates: Prisma.$HotmartAffiliatesPayload<ExtArgs>[]
      hotmartBuyer: Prisma.$HotmartBuyerPayload<ExtArgs>
      hotmartPurchase: Prisma.$HotmartPurchasePayload<ExtArgs>
      hotmartSubscription: Prisma.$HotmartSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      externalWebhookHotmartReceiverId: number
      hotmartProductId: number
      hotmartBuyerId: number
      producerName: string | null
      hotmartPurchaseId: number
      hotmartSubscriptionId: number | null
    }, ExtArgs["result"]["hotmartOrderNote"]>
    composites: {}
  }

  type HotmartOrderNoteGetPayload<S extends boolean | null | undefined | HotmartOrderNoteDefaultArgs> = $Result.GetResult<Prisma.$HotmartOrderNotePayload, S>

  type HotmartOrderNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartOrderNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartOrderNoteCountAggregateInputType | true
    }

  export interface HotmartOrderNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartOrderNote'], meta: { name: 'HotmartOrderNote' } }
    /**
     * Find zero or one HotmartOrderNote that matches the filter.
     * @param {HotmartOrderNoteFindUniqueArgs} args - Arguments to find a HotmartOrderNote
     * @example
     * // Get one HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartOrderNoteFindUniqueArgs>(args: SelectSubset<T, HotmartOrderNoteFindUniqueArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartOrderNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartOrderNoteFindUniqueOrThrowArgs} args - Arguments to find a HotmartOrderNote
     * @example
     * // Get one HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartOrderNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartOrderNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartOrderNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteFindFirstArgs} args - Arguments to find a HotmartOrderNote
     * @example
     * // Get one HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartOrderNoteFindFirstArgs>(args?: SelectSubset<T, HotmartOrderNoteFindFirstArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartOrderNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteFindFirstOrThrowArgs} args - Arguments to find a HotmartOrderNote
     * @example
     * // Get one HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartOrderNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartOrderNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartOrderNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartOrderNotes
     * const hotmartOrderNotes = await prisma.hotmartOrderNote.findMany()
     * 
     * // Get first 10 HotmartOrderNotes
     * const hotmartOrderNotes = await prisma.hotmartOrderNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartOrderNoteWithIdOnly = await prisma.hotmartOrderNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartOrderNoteFindManyArgs>(args?: SelectSubset<T, HotmartOrderNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartOrderNote.
     * @param {HotmartOrderNoteCreateArgs} args - Arguments to create a HotmartOrderNote.
     * @example
     * // Create one HotmartOrderNote
     * const HotmartOrderNote = await prisma.hotmartOrderNote.create({
     *   data: {
     *     // ... data to create a HotmartOrderNote
     *   }
     * })
     * 
     */
    create<T extends HotmartOrderNoteCreateArgs>(args: SelectSubset<T, HotmartOrderNoteCreateArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartOrderNotes.
     * @param {HotmartOrderNoteCreateManyArgs} args - Arguments to create many HotmartOrderNotes.
     * @example
     * // Create many HotmartOrderNotes
     * const hotmartOrderNote = await prisma.hotmartOrderNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartOrderNoteCreateManyArgs>(args?: SelectSubset<T, HotmartOrderNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartOrderNotes and returns the data saved in the database.
     * @param {HotmartOrderNoteCreateManyAndReturnArgs} args - Arguments to create many HotmartOrderNotes.
     * @example
     * // Create many HotmartOrderNotes
     * const hotmartOrderNote = await prisma.hotmartOrderNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartOrderNotes and only return the `id`
     * const hotmartOrderNoteWithIdOnly = await prisma.hotmartOrderNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartOrderNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartOrderNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartOrderNote.
     * @param {HotmartOrderNoteDeleteArgs} args - Arguments to delete one HotmartOrderNote.
     * @example
     * // Delete one HotmartOrderNote
     * const HotmartOrderNote = await prisma.hotmartOrderNote.delete({
     *   where: {
     *     // ... filter to delete one HotmartOrderNote
     *   }
     * })
     * 
     */
    delete<T extends HotmartOrderNoteDeleteArgs>(args: SelectSubset<T, HotmartOrderNoteDeleteArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartOrderNote.
     * @param {HotmartOrderNoteUpdateArgs} args - Arguments to update one HotmartOrderNote.
     * @example
     * // Update one HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartOrderNoteUpdateArgs>(args: SelectSubset<T, HotmartOrderNoteUpdateArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartOrderNotes.
     * @param {HotmartOrderNoteDeleteManyArgs} args - Arguments to filter HotmartOrderNotes to delete.
     * @example
     * // Delete a few HotmartOrderNotes
     * const { count } = await prisma.hotmartOrderNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartOrderNoteDeleteManyArgs>(args?: SelectSubset<T, HotmartOrderNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartOrderNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartOrderNotes
     * const hotmartOrderNote = await prisma.hotmartOrderNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartOrderNoteUpdateManyArgs>(args: SelectSubset<T, HotmartOrderNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartOrderNote.
     * @param {HotmartOrderNoteUpsertArgs} args - Arguments to update or create a HotmartOrderNote.
     * @example
     * // Update or create a HotmartOrderNote
     * const hotmartOrderNote = await prisma.hotmartOrderNote.upsert({
     *   create: {
     *     // ... data to create a HotmartOrderNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartOrderNote we want to update
     *   }
     * })
     */
    upsert<T extends HotmartOrderNoteUpsertArgs>(args: SelectSubset<T, HotmartOrderNoteUpsertArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartOrderNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteCountArgs} args - Arguments to filter HotmartOrderNotes to count.
     * @example
     * // Count the number of HotmartOrderNotes
     * const count = await prisma.hotmartOrderNote.count({
     *   where: {
     *     // ... the filter for the HotmartOrderNotes we want to count
     *   }
     * })
    **/
    count<T extends HotmartOrderNoteCountArgs>(
      args?: Subset<T, HotmartOrderNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartOrderNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartOrderNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartOrderNoteAggregateArgs>(args: Subset<T, HotmartOrderNoteAggregateArgs>): Prisma.PrismaPromise<GetHotmartOrderNoteAggregateType<T>>

    /**
     * Group by HotmartOrderNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartOrderNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartOrderNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartOrderNoteGroupByArgs['orderBy'] }
        : { orderBy?: HotmartOrderNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartOrderNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartOrderNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartOrderNote model
   */
  readonly fields: HotmartOrderNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartOrderNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartOrderNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    externalWebhookHotmartReceiver<T extends ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>>): Prisma__ExternalWebhookHotmartReceiverClient<$Result.GetResult<Prisma.$ExternalWebhookHotmartReceiverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotmartProduct<T extends HotmartProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotmartProductDefaultArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotmartAffiliates<T extends HotmartOrderNote$hotmartAffiliatesArgs<ExtArgs> = {}>(args?: Subset<T, HotmartOrderNote$hotmartAffiliatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findMany"> | Null>
    hotmartBuyer<T extends HotmartBuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotmartBuyerDefaultArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotmartPurchase<T extends HotmartPurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotmartPurchaseDefaultArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotmartSubscription<T extends HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartOrderNote model
   */ 
  interface HotmartOrderNoteFieldRefs {
    readonly id: FieldRef<"HotmartOrderNote", 'Int'>
    readonly creationDate: FieldRef<"HotmartOrderNote", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartOrderNote", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartOrderNote", 'DateTime'>
    readonly externalWebhookHotmartReceiverId: FieldRef<"HotmartOrderNote", 'Int'>
    readonly hotmartProductId: FieldRef<"HotmartOrderNote", 'Int'>
    readonly hotmartBuyerId: FieldRef<"HotmartOrderNote", 'Int'>
    readonly producerName: FieldRef<"HotmartOrderNote", 'String'>
    readonly hotmartPurchaseId: FieldRef<"HotmartOrderNote", 'Int'>
    readonly hotmartSubscriptionId: FieldRef<"HotmartOrderNote", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotmartOrderNote findUnique
   */
  export type HotmartOrderNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter, which HotmartOrderNote to fetch.
     */
    where: HotmartOrderNoteWhereUniqueInput
  }

  /**
   * HotmartOrderNote findUniqueOrThrow
   */
  export type HotmartOrderNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter, which HotmartOrderNote to fetch.
     */
    where: HotmartOrderNoteWhereUniqueInput
  }

  /**
   * HotmartOrderNote findFirst
   */
  export type HotmartOrderNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter, which HotmartOrderNote to fetch.
     */
    where?: HotmartOrderNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartOrderNotes to fetch.
     */
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartOrderNotes.
     */
    cursor?: HotmartOrderNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartOrderNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartOrderNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartOrderNotes.
     */
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartOrderNote findFirstOrThrow
   */
  export type HotmartOrderNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter, which HotmartOrderNote to fetch.
     */
    where?: HotmartOrderNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartOrderNotes to fetch.
     */
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartOrderNotes.
     */
    cursor?: HotmartOrderNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartOrderNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartOrderNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartOrderNotes.
     */
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartOrderNote findMany
   */
  export type HotmartOrderNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter, which HotmartOrderNotes to fetch.
     */
    where?: HotmartOrderNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartOrderNotes to fetch.
     */
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartOrderNotes.
     */
    cursor?: HotmartOrderNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartOrderNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartOrderNotes.
     */
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartOrderNote create
   */
  export type HotmartOrderNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartOrderNote.
     */
    data: XOR<HotmartOrderNoteCreateInput, HotmartOrderNoteUncheckedCreateInput>
  }

  /**
   * HotmartOrderNote createMany
   */
  export type HotmartOrderNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartOrderNotes.
     */
    data: HotmartOrderNoteCreateManyInput | HotmartOrderNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartOrderNote createManyAndReturn
   */
  export type HotmartOrderNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartOrderNotes.
     */
    data: HotmartOrderNoteCreateManyInput | HotmartOrderNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotmartOrderNote update
   */
  export type HotmartOrderNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartOrderNote.
     */
    data: XOR<HotmartOrderNoteUpdateInput, HotmartOrderNoteUncheckedUpdateInput>
    /**
     * Choose, which HotmartOrderNote to update.
     */
    where: HotmartOrderNoteWhereUniqueInput
  }

  /**
   * HotmartOrderNote updateMany
   */
  export type HotmartOrderNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartOrderNotes.
     */
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyInput>
    /**
     * Filter which HotmartOrderNotes to update
     */
    where?: HotmartOrderNoteWhereInput
  }

  /**
   * HotmartOrderNote upsert
   */
  export type HotmartOrderNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartOrderNote to update in case it exists.
     */
    where: HotmartOrderNoteWhereUniqueInput
    /**
     * In case the HotmartOrderNote found by the `where` argument doesn't exist, create a new HotmartOrderNote with this data.
     */
    create: XOR<HotmartOrderNoteCreateInput, HotmartOrderNoteUncheckedCreateInput>
    /**
     * In case the HotmartOrderNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartOrderNoteUpdateInput, HotmartOrderNoteUncheckedUpdateInput>
  }

  /**
   * HotmartOrderNote delete
   */
  export type HotmartOrderNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    /**
     * Filter which HotmartOrderNote to delete.
     */
    where: HotmartOrderNoteWhereUniqueInput
  }

  /**
   * HotmartOrderNote deleteMany
   */
  export type HotmartOrderNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartOrderNotes to delete
     */
    where?: HotmartOrderNoteWhereInput
  }

  /**
   * HotmartOrderNote.hotmartAffiliates
   */
  export type HotmartOrderNote$hotmartAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    where?: HotmartAffiliatesWhereInput
    orderBy?: HotmartAffiliatesOrderByWithRelationInput | HotmartAffiliatesOrderByWithRelationInput[]
    cursor?: HotmartAffiliatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartAffiliatesScalarFieldEnum | HotmartAffiliatesScalarFieldEnum[]
  }

  /**
   * HotmartOrderNote.hotmartSubscription
   */
  export type HotmartOrderNote$hotmartSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    where?: HotmartSubscriptionWhereInput
  }

  /**
   * HotmartOrderNote without action
   */
  export type HotmartOrderNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
  }


  /**
   * Model HotmartProduct
   */

  export type AggregateHotmartProduct = {
    _count: HotmartProductCountAggregateOutputType | null
    _avg: HotmartProductAvgAggregateOutputType | null
    _sum: HotmartProductSumAggregateOutputType | null
    _min: HotmartProductMinAggregateOutputType | null
    _max: HotmartProductMaxAggregateOutputType | null
  }

  export type HotmartProductAvgAggregateOutputType = {
    id: number | null
  }

  export type HotmartProductSumAggregateOutputType = {
    id: number | null
  }

  export type HotmartProductMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    lastOrderDate: Date | null
    productUcode: string | null
    productName: string | null
    productHasCoProduction: boolean | null
  }

  export type HotmartProductMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    lastOrderDate: Date | null
    productUcode: string | null
    productName: string | null
    productHasCoProduction: boolean | null
  }

  export type HotmartProductCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    lastOrderDate: number
    productUcode: number
    productName: number
    productHasCoProduction: number
    _all: number
  }


  export type HotmartProductAvgAggregateInputType = {
    id?: true
  }

  export type HotmartProductSumAggregateInputType = {
    id?: true
  }

  export type HotmartProductMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    productUcode?: true
    productName?: true
    productHasCoProduction?: true
  }

  export type HotmartProductMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    productUcode?: true
    productName?: true
    productHasCoProduction?: true
  }

  export type HotmartProductCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    productUcode?: true
    productName?: true
    productHasCoProduction?: true
    _all?: true
  }

  export type HotmartProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartProduct to aggregate.
     */
    where?: HotmartProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartProducts to fetch.
     */
    orderBy?: HotmartProductOrderByWithRelationInput | HotmartProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartProducts
    **/
    _count?: true | HotmartProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartProductMaxAggregateInputType
  }

  export type GetHotmartProductAggregateType<T extends HotmartProductAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartProduct[P]>
      : GetScalarType<T[P], AggregateHotmartProduct[P]>
  }




  export type HotmartProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartProductWhereInput
    orderBy?: HotmartProductOrderByWithAggregationInput | HotmartProductOrderByWithAggregationInput[]
    by: HotmartProductScalarFieldEnum[] | HotmartProductScalarFieldEnum
    having?: HotmartProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartProductCountAggregateInputType | true
    _avg?: HotmartProductAvgAggregateInputType
    _sum?: HotmartProductSumAggregateInputType
    _min?: HotmartProductMinAggregateInputType
    _max?: HotmartProductMaxAggregateInputType
  }

  export type HotmartProductGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    lastOrderDate: Date | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
    _count: HotmartProductCountAggregateOutputType | null
    _avg: HotmartProductAvgAggregateOutputType | null
    _sum: HotmartProductSumAggregateOutputType | null
    _min: HotmartProductMinAggregateOutputType | null
    _max: HotmartProductMaxAggregateOutputType | null
  }

  type GetHotmartProductGroupByPayload<T extends HotmartProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartProductGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartProductGroupByOutputType[P]>
        }
      >
    >


  export type HotmartProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    productUcode?: boolean
    productName?: boolean
    productHasCoProduction?: boolean
    HotmartOrderNote?: boolean | HotmartProduct$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartProduct"]>

  export type HotmartProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    productUcode?: boolean
    productName?: boolean
    productHasCoProduction?: boolean
  }, ExtArgs["result"]["hotmartProduct"]>

  export type HotmartProductSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    productUcode?: boolean
    productName?: boolean
    productHasCoProduction?: boolean
  }

  export type HotmartProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartProduct$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotmartProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotmartProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartProduct"
    objects: {
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      lastOrderDate: Date | null
      productUcode: string
      productName: string
      productHasCoProduction: boolean
    }, ExtArgs["result"]["hotmartProduct"]>
    composites: {}
  }

  type HotmartProductGetPayload<S extends boolean | null | undefined | HotmartProductDefaultArgs> = $Result.GetResult<Prisma.$HotmartProductPayload, S>

  type HotmartProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartProductCountAggregateInputType | true
    }

  export interface HotmartProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartProduct'], meta: { name: 'HotmartProduct' } }
    /**
     * Find zero or one HotmartProduct that matches the filter.
     * @param {HotmartProductFindUniqueArgs} args - Arguments to find a HotmartProduct
     * @example
     * // Get one HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartProductFindUniqueArgs>(args: SelectSubset<T, HotmartProductFindUniqueArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartProductFindUniqueOrThrowArgs} args - Arguments to find a HotmartProduct
     * @example
     * // Get one HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartProductFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductFindFirstArgs} args - Arguments to find a HotmartProduct
     * @example
     * // Get one HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartProductFindFirstArgs>(args?: SelectSubset<T, HotmartProductFindFirstArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductFindFirstOrThrowArgs} args - Arguments to find a HotmartProduct
     * @example
     * // Get one HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartProductFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartProducts
     * const hotmartProducts = await prisma.hotmartProduct.findMany()
     * 
     * // Get first 10 HotmartProducts
     * const hotmartProducts = await prisma.hotmartProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartProductWithIdOnly = await prisma.hotmartProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartProductFindManyArgs>(args?: SelectSubset<T, HotmartProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartProduct.
     * @param {HotmartProductCreateArgs} args - Arguments to create a HotmartProduct.
     * @example
     * // Create one HotmartProduct
     * const HotmartProduct = await prisma.hotmartProduct.create({
     *   data: {
     *     // ... data to create a HotmartProduct
     *   }
     * })
     * 
     */
    create<T extends HotmartProductCreateArgs>(args: SelectSubset<T, HotmartProductCreateArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartProducts.
     * @param {HotmartProductCreateManyArgs} args - Arguments to create many HotmartProducts.
     * @example
     * // Create many HotmartProducts
     * const hotmartProduct = await prisma.hotmartProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartProductCreateManyArgs>(args?: SelectSubset<T, HotmartProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartProducts and returns the data saved in the database.
     * @param {HotmartProductCreateManyAndReturnArgs} args - Arguments to create many HotmartProducts.
     * @example
     * // Create many HotmartProducts
     * const hotmartProduct = await prisma.hotmartProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartProducts and only return the `id`
     * const hotmartProductWithIdOnly = await prisma.hotmartProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartProductCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartProduct.
     * @param {HotmartProductDeleteArgs} args - Arguments to delete one HotmartProduct.
     * @example
     * // Delete one HotmartProduct
     * const HotmartProduct = await prisma.hotmartProduct.delete({
     *   where: {
     *     // ... filter to delete one HotmartProduct
     *   }
     * })
     * 
     */
    delete<T extends HotmartProductDeleteArgs>(args: SelectSubset<T, HotmartProductDeleteArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartProduct.
     * @param {HotmartProductUpdateArgs} args - Arguments to update one HotmartProduct.
     * @example
     * // Update one HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartProductUpdateArgs>(args: SelectSubset<T, HotmartProductUpdateArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartProducts.
     * @param {HotmartProductDeleteManyArgs} args - Arguments to filter HotmartProducts to delete.
     * @example
     * // Delete a few HotmartProducts
     * const { count } = await prisma.hotmartProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartProductDeleteManyArgs>(args?: SelectSubset<T, HotmartProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartProducts
     * const hotmartProduct = await prisma.hotmartProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartProductUpdateManyArgs>(args: SelectSubset<T, HotmartProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartProduct.
     * @param {HotmartProductUpsertArgs} args - Arguments to update or create a HotmartProduct.
     * @example
     * // Update or create a HotmartProduct
     * const hotmartProduct = await prisma.hotmartProduct.upsert({
     *   create: {
     *     // ... data to create a HotmartProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartProduct we want to update
     *   }
     * })
     */
    upsert<T extends HotmartProductUpsertArgs>(args: SelectSubset<T, HotmartProductUpsertArgs<ExtArgs>>): Prisma__HotmartProductClient<$Result.GetResult<Prisma.$HotmartProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductCountArgs} args - Arguments to filter HotmartProducts to count.
     * @example
     * // Count the number of HotmartProducts
     * const count = await prisma.hotmartProduct.count({
     *   where: {
     *     // ... the filter for the HotmartProducts we want to count
     *   }
     * })
    **/
    count<T extends HotmartProductCountArgs>(
      args?: Subset<T, HotmartProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartProductAggregateArgs>(args: Subset<T, HotmartProductAggregateArgs>): Prisma.PrismaPromise<GetHotmartProductAggregateType<T>>

    /**
     * Group by HotmartProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartProductGroupByArgs['orderBy'] }
        : { orderBy?: HotmartProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartProduct model
   */
  readonly fields: HotmartProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartOrderNote<T extends HotmartProduct$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, HotmartProduct$HotmartOrderNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartProduct model
   */ 
  interface HotmartProductFieldRefs {
    readonly id: FieldRef<"HotmartProduct", 'Int'>
    readonly creationDate: FieldRef<"HotmartProduct", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartProduct", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartProduct", 'DateTime'>
    readonly lastOrderDate: FieldRef<"HotmartProduct", 'DateTime'>
    readonly productUcode: FieldRef<"HotmartProduct", 'String'>
    readonly productName: FieldRef<"HotmartProduct", 'String'>
    readonly productHasCoProduction: FieldRef<"HotmartProduct", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HotmartProduct findUnique
   */
  export type HotmartProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter, which HotmartProduct to fetch.
     */
    where: HotmartProductWhereUniqueInput
  }

  /**
   * HotmartProduct findUniqueOrThrow
   */
  export type HotmartProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter, which HotmartProduct to fetch.
     */
    where: HotmartProductWhereUniqueInput
  }

  /**
   * HotmartProduct findFirst
   */
  export type HotmartProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter, which HotmartProduct to fetch.
     */
    where?: HotmartProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartProducts to fetch.
     */
    orderBy?: HotmartProductOrderByWithRelationInput | HotmartProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartProducts.
     */
    cursor?: HotmartProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartProducts.
     */
    distinct?: HotmartProductScalarFieldEnum | HotmartProductScalarFieldEnum[]
  }

  /**
   * HotmartProduct findFirstOrThrow
   */
  export type HotmartProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter, which HotmartProduct to fetch.
     */
    where?: HotmartProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartProducts to fetch.
     */
    orderBy?: HotmartProductOrderByWithRelationInput | HotmartProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartProducts.
     */
    cursor?: HotmartProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartProducts.
     */
    distinct?: HotmartProductScalarFieldEnum | HotmartProductScalarFieldEnum[]
  }

  /**
   * HotmartProduct findMany
   */
  export type HotmartProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter, which HotmartProducts to fetch.
     */
    where?: HotmartProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartProducts to fetch.
     */
    orderBy?: HotmartProductOrderByWithRelationInput | HotmartProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartProducts.
     */
    cursor?: HotmartProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartProducts.
     */
    skip?: number
    distinct?: HotmartProductScalarFieldEnum | HotmartProductScalarFieldEnum[]
  }

  /**
   * HotmartProduct create
   */
  export type HotmartProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartProduct.
     */
    data: XOR<HotmartProductCreateInput, HotmartProductUncheckedCreateInput>
  }

  /**
   * HotmartProduct createMany
   */
  export type HotmartProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartProducts.
     */
    data: HotmartProductCreateManyInput | HotmartProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartProduct createManyAndReturn
   */
  export type HotmartProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartProducts.
     */
    data: HotmartProductCreateManyInput | HotmartProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartProduct update
   */
  export type HotmartProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartProduct.
     */
    data: XOR<HotmartProductUpdateInput, HotmartProductUncheckedUpdateInput>
    /**
     * Choose, which HotmartProduct to update.
     */
    where: HotmartProductWhereUniqueInput
  }

  /**
   * HotmartProduct updateMany
   */
  export type HotmartProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartProducts.
     */
    data: XOR<HotmartProductUpdateManyMutationInput, HotmartProductUncheckedUpdateManyInput>
    /**
     * Filter which HotmartProducts to update
     */
    where?: HotmartProductWhereInput
  }

  /**
   * HotmartProduct upsert
   */
  export type HotmartProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartProduct to update in case it exists.
     */
    where: HotmartProductWhereUniqueInput
    /**
     * In case the HotmartProduct found by the `where` argument doesn't exist, create a new HotmartProduct with this data.
     */
    create: XOR<HotmartProductCreateInput, HotmartProductUncheckedCreateInput>
    /**
     * In case the HotmartProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartProductUpdateInput, HotmartProductUncheckedUpdateInput>
  }

  /**
   * HotmartProduct delete
   */
  export type HotmartProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
    /**
     * Filter which HotmartProduct to delete.
     */
    where: HotmartProductWhereUniqueInput
  }

  /**
   * HotmartProduct deleteMany
   */
  export type HotmartProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartProducts to delete
     */
    where?: HotmartProductWhereInput
  }

  /**
   * HotmartProduct.HotmartOrderNote
   */
  export type HotmartProduct$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    cursor?: HotmartOrderNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartProduct without action
   */
  export type HotmartProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartProduct
     */
    select?: HotmartProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartProductInclude<ExtArgs> | null
  }


  /**
   * Model HotmartAffiliates
   */

  export type AggregateHotmartAffiliates = {
    _count: HotmartAffiliatesCountAggregateOutputType | null
    _avg: HotmartAffiliatesAvgAggregateOutputType | null
    _sum: HotmartAffiliatesSumAggregateOutputType | null
    _min: HotmartAffiliatesMinAggregateOutputType | null
    _max: HotmartAffiliatesMaxAggregateOutputType | null
  }

  export type HotmartAffiliatesAvgAggregateOutputType = {
    id: number | null
    hotmartOrderNoteId: number | null
  }

  export type HotmartAffiliatesSumAggregateOutputType = {
    id: number | null
    hotmartOrderNoteId: number | null
  }

  export type HotmartAffiliatesMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    lastOrderDate: Date | null
    affiliateCode: string | null
    affiliateName: string | null
    hotmartOrderNoteId: number | null
  }

  export type HotmartAffiliatesMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    lastOrderDate: Date | null
    affiliateCode: string | null
    affiliateName: string | null
    hotmartOrderNoteId: number | null
  }

  export type HotmartAffiliatesCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    lastOrderDate: number
    affiliateCode: number
    affiliateName: number
    hotmartOrderNoteId: number
    _all: number
  }


  export type HotmartAffiliatesAvgAggregateInputType = {
    id?: true
    hotmartOrderNoteId?: true
  }

  export type HotmartAffiliatesSumAggregateInputType = {
    id?: true
    hotmartOrderNoteId?: true
  }

  export type HotmartAffiliatesMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    affiliateCode?: true
    affiliateName?: true
    hotmartOrderNoteId?: true
  }

  export type HotmartAffiliatesMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    affiliateCode?: true
    affiliateName?: true
    hotmartOrderNoteId?: true
  }

  export type HotmartAffiliatesCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    lastOrderDate?: true
    affiliateCode?: true
    affiliateName?: true
    hotmartOrderNoteId?: true
    _all?: true
  }

  export type HotmartAffiliatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartAffiliates to aggregate.
     */
    where?: HotmartAffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartAffiliates to fetch.
     */
    orderBy?: HotmartAffiliatesOrderByWithRelationInput | HotmartAffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartAffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartAffiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartAffiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartAffiliates
    **/
    _count?: true | HotmartAffiliatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartAffiliatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartAffiliatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartAffiliatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartAffiliatesMaxAggregateInputType
  }

  export type GetHotmartAffiliatesAggregateType<T extends HotmartAffiliatesAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartAffiliates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartAffiliates[P]>
      : GetScalarType<T[P], AggregateHotmartAffiliates[P]>
  }




  export type HotmartAffiliatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartAffiliatesWhereInput
    orderBy?: HotmartAffiliatesOrderByWithAggregationInput | HotmartAffiliatesOrderByWithAggregationInput[]
    by: HotmartAffiliatesScalarFieldEnum[] | HotmartAffiliatesScalarFieldEnum
    having?: HotmartAffiliatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartAffiliatesCountAggregateInputType | true
    _avg?: HotmartAffiliatesAvgAggregateInputType
    _sum?: HotmartAffiliatesSumAggregateInputType
    _min?: HotmartAffiliatesMinAggregateInputType
    _max?: HotmartAffiliatesMaxAggregateInputType
  }

  export type HotmartAffiliatesGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    lastOrderDate: Date | null
    affiliateCode: string | null
    affiliateName: string | null
    hotmartOrderNoteId: number | null
    _count: HotmartAffiliatesCountAggregateOutputType | null
    _avg: HotmartAffiliatesAvgAggregateOutputType | null
    _sum: HotmartAffiliatesSumAggregateOutputType | null
    _min: HotmartAffiliatesMinAggregateOutputType | null
    _max: HotmartAffiliatesMaxAggregateOutputType | null
  }

  type GetHotmartAffiliatesGroupByPayload<T extends HotmartAffiliatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartAffiliatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartAffiliatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartAffiliatesGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartAffiliatesGroupByOutputType[P]>
        }
      >
    >


  export type HotmartAffiliatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    affiliateCode?: boolean
    affiliateName?: boolean
    hotmartOrderNoteId?: boolean
    HotmartOrderNote?: boolean | HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartAffiliates"]>

  export type HotmartAffiliatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    affiliateCode?: boolean
    affiliateName?: boolean
    hotmartOrderNoteId?: boolean
    HotmartOrderNote?: boolean | HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartAffiliates"]>

  export type HotmartAffiliatesSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    lastOrderDate?: boolean
    affiliateCode?: boolean
    affiliateName?: boolean
    hotmartOrderNoteId?: boolean
  }

  export type HotmartAffiliatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs>
  }
  export type HotmartAffiliatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs>
  }

  export type $HotmartAffiliatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartAffiliates"
    objects: {
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      lastOrderDate: Date | null
      affiliateCode: string | null
      affiliateName: string | null
      hotmartOrderNoteId: number | null
    }, ExtArgs["result"]["hotmartAffiliates"]>
    composites: {}
  }

  type HotmartAffiliatesGetPayload<S extends boolean | null | undefined | HotmartAffiliatesDefaultArgs> = $Result.GetResult<Prisma.$HotmartAffiliatesPayload, S>

  type HotmartAffiliatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartAffiliatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartAffiliatesCountAggregateInputType | true
    }

  export interface HotmartAffiliatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartAffiliates'], meta: { name: 'HotmartAffiliates' } }
    /**
     * Find zero or one HotmartAffiliates that matches the filter.
     * @param {HotmartAffiliatesFindUniqueArgs} args - Arguments to find a HotmartAffiliates
     * @example
     * // Get one HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartAffiliatesFindUniqueArgs>(args: SelectSubset<T, HotmartAffiliatesFindUniqueArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartAffiliates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartAffiliatesFindUniqueOrThrowArgs} args - Arguments to find a HotmartAffiliates
     * @example
     * // Get one HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartAffiliatesFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartAffiliatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartAffiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesFindFirstArgs} args - Arguments to find a HotmartAffiliates
     * @example
     * // Get one HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartAffiliatesFindFirstArgs>(args?: SelectSubset<T, HotmartAffiliatesFindFirstArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartAffiliates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesFindFirstOrThrowArgs} args - Arguments to find a HotmartAffiliates
     * @example
     * // Get one HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartAffiliatesFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartAffiliatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartAffiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findMany()
     * 
     * // Get first 10 HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartAffiliatesWithIdOnly = await prisma.hotmartAffiliates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartAffiliatesFindManyArgs>(args?: SelectSubset<T, HotmartAffiliatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartAffiliates.
     * @param {HotmartAffiliatesCreateArgs} args - Arguments to create a HotmartAffiliates.
     * @example
     * // Create one HotmartAffiliates
     * const HotmartAffiliates = await prisma.hotmartAffiliates.create({
     *   data: {
     *     // ... data to create a HotmartAffiliates
     *   }
     * })
     * 
     */
    create<T extends HotmartAffiliatesCreateArgs>(args: SelectSubset<T, HotmartAffiliatesCreateArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartAffiliates.
     * @param {HotmartAffiliatesCreateManyArgs} args - Arguments to create many HotmartAffiliates.
     * @example
     * // Create many HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartAffiliatesCreateManyArgs>(args?: SelectSubset<T, HotmartAffiliatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartAffiliates and returns the data saved in the database.
     * @param {HotmartAffiliatesCreateManyAndReturnArgs} args - Arguments to create many HotmartAffiliates.
     * @example
     * // Create many HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartAffiliates and only return the `id`
     * const hotmartAffiliatesWithIdOnly = await prisma.hotmartAffiliates.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartAffiliatesCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartAffiliatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartAffiliates.
     * @param {HotmartAffiliatesDeleteArgs} args - Arguments to delete one HotmartAffiliates.
     * @example
     * // Delete one HotmartAffiliates
     * const HotmartAffiliates = await prisma.hotmartAffiliates.delete({
     *   where: {
     *     // ... filter to delete one HotmartAffiliates
     *   }
     * })
     * 
     */
    delete<T extends HotmartAffiliatesDeleteArgs>(args: SelectSubset<T, HotmartAffiliatesDeleteArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartAffiliates.
     * @param {HotmartAffiliatesUpdateArgs} args - Arguments to update one HotmartAffiliates.
     * @example
     * // Update one HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartAffiliatesUpdateArgs>(args: SelectSubset<T, HotmartAffiliatesUpdateArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartAffiliates.
     * @param {HotmartAffiliatesDeleteManyArgs} args - Arguments to filter HotmartAffiliates to delete.
     * @example
     * // Delete a few HotmartAffiliates
     * const { count } = await prisma.hotmartAffiliates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartAffiliatesDeleteManyArgs>(args?: SelectSubset<T, HotmartAffiliatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartAffiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartAffiliatesUpdateManyArgs>(args: SelectSubset<T, HotmartAffiliatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartAffiliates.
     * @param {HotmartAffiliatesUpsertArgs} args - Arguments to update or create a HotmartAffiliates.
     * @example
     * // Update or create a HotmartAffiliates
     * const hotmartAffiliates = await prisma.hotmartAffiliates.upsert({
     *   create: {
     *     // ... data to create a HotmartAffiliates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartAffiliates we want to update
     *   }
     * })
     */
    upsert<T extends HotmartAffiliatesUpsertArgs>(args: SelectSubset<T, HotmartAffiliatesUpsertArgs<ExtArgs>>): Prisma__HotmartAffiliatesClient<$Result.GetResult<Prisma.$HotmartAffiliatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartAffiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesCountArgs} args - Arguments to filter HotmartAffiliates to count.
     * @example
     * // Count the number of HotmartAffiliates
     * const count = await prisma.hotmartAffiliates.count({
     *   where: {
     *     // ... the filter for the HotmartAffiliates we want to count
     *   }
     * })
    **/
    count<T extends HotmartAffiliatesCountArgs>(
      args?: Subset<T, HotmartAffiliatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartAffiliatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartAffiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartAffiliatesAggregateArgs>(args: Subset<T, HotmartAffiliatesAggregateArgs>): Prisma.PrismaPromise<GetHotmartAffiliatesAggregateType<T>>

    /**
     * Group by HotmartAffiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartAffiliatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartAffiliatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartAffiliatesGroupByArgs['orderBy'] }
        : { orderBy?: HotmartAffiliatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartAffiliatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartAffiliatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartAffiliates model
   */
  readonly fields: HotmartAffiliatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartAffiliates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartAffiliatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartOrderNote<T extends HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs>>): Prisma__HotmartOrderNoteClient<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartAffiliates model
   */ 
  interface HotmartAffiliatesFieldRefs {
    readonly id: FieldRef<"HotmartAffiliates", 'Int'>
    readonly creationDate: FieldRef<"HotmartAffiliates", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartAffiliates", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartAffiliates", 'DateTime'>
    readonly lastOrderDate: FieldRef<"HotmartAffiliates", 'DateTime'>
    readonly affiliateCode: FieldRef<"HotmartAffiliates", 'String'>
    readonly affiliateName: FieldRef<"HotmartAffiliates", 'String'>
    readonly hotmartOrderNoteId: FieldRef<"HotmartAffiliates", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotmartAffiliates findUnique
   */
  export type HotmartAffiliatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which HotmartAffiliates to fetch.
     */
    where: HotmartAffiliatesWhereUniqueInput
  }

  /**
   * HotmartAffiliates findUniqueOrThrow
   */
  export type HotmartAffiliatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which HotmartAffiliates to fetch.
     */
    where: HotmartAffiliatesWhereUniqueInput
  }

  /**
   * HotmartAffiliates findFirst
   */
  export type HotmartAffiliatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which HotmartAffiliates to fetch.
     */
    where?: HotmartAffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartAffiliates to fetch.
     */
    orderBy?: HotmartAffiliatesOrderByWithRelationInput | HotmartAffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartAffiliates.
     */
    cursor?: HotmartAffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartAffiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartAffiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartAffiliates.
     */
    distinct?: HotmartAffiliatesScalarFieldEnum | HotmartAffiliatesScalarFieldEnum[]
  }

  /**
   * HotmartAffiliates findFirstOrThrow
   */
  export type HotmartAffiliatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which HotmartAffiliates to fetch.
     */
    where?: HotmartAffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartAffiliates to fetch.
     */
    orderBy?: HotmartAffiliatesOrderByWithRelationInput | HotmartAffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartAffiliates.
     */
    cursor?: HotmartAffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartAffiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartAffiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartAffiliates.
     */
    distinct?: HotmartAffiliatesScalarFieldEnum | HotmartAffiliatesScalarFieldEnum[]
  }

  /**
   * HotmartAffiliates findMany
   */
  export type HotmartAffiliatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which HotmartAffiliates to fetch.
     */
    where?: HotmartAffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartAffiliates to fetch.
     */
    orderBy?: HotmartAffiliatesOrderByWithRelationInput | HotmartAffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartAffiliates.
     */
    cursor?: HotmartAffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartAffiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartAffiliates.
     */
    skip?: number
    distinct?: HotmartAffiliatesScalarFieldEnum | HotmartAffiliatesScalarFieldEnum[]
  }

  /**
   * HotmartAffiliates create
   */
  export type HotmartAffiliatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartAffiliates.
     */
    data: XOR<HotmartAffiliatesCreateInput, HotmartAffiliatesUncheckedCreateInput>
  }

  /**
   * HotmartAffiliates createMany
   */
  export type HotmartAffiliatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartAffiliates.
     */
    data: HotmartAffiliatesCreateManyInput | HotmartAffiliatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartAffiliates createManyAndReturn
   */
  export type HotmartAffiliatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartAffiliates.
     */
    data: HotmartAffiliatesCreateManyInput | HotmartAffiliatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotmartAffiliates update
   */
  export type HotmartAffiliatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartAffiliates.
     */
    data: XOR<HotmartAffiliatesUpdateInput, HotmartAffiliatesUncheckedUpdateInput>
    /**
     * Choose, which HotmartAffiliates to update.
     */
    where: HotmartAffiliatesWhereUniqueInput
  }

  /**
   * HotmartAffiliates updateMany
   */
  export type HotmartAffiliatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartAffiliates.
     */
    data: XOR<HotmartAffiliatesUpdateManyMutationInput, HotmartAffiliatesUncheckedUpdateManyInput>
    /**
     * Filter which HotmartAffiliates to update
     */
    where?: HotmartAffiliatesWhereInput
  }

  /**
   * HotmartAffiliates upsert
   */
  export type HotmartAffiliatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartAffiliates to update in case it exists.
     */
    where: HotmartAffiliatesWhereUniqueInput
    /**
     * In case the HotmartAffiliates found by the `where` argument doesn't exist, create a new HotmartAffiliates with this data.
     */
    create: XOR<HotmartAffiliatesCreateInput, HotmartAffiliatesUncheckedCreateInput>
    /**
     * In case the HotmartAffiliates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartAffiliatesUpdateInput, HotmartAffiliatesUncheckedUpdateInput>
  }

  /**
   * HotmartAffiliates delete
   */
  export type HotmartAffiliatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
    /**
     * Filter which HotmartAffiliates to delete.
     */
    where: HotmartAffiliatesWhereUniqueInput
  }

  /**
   * HotmartAffiliates deleteMany
   */
  export type HotmartAffiliatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartAffiliates to delete
     */
    where?: HotmartAffiliatesWhereInput
  }

  /**
   * HotmartAffiliates.HotmartOrderNote
   */
  export type HotmartAffiliates$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
  }

  /**
   * HotmartAffiliates without action
   */
  export type HotmartAffiliatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartAffiliates
     */
    select?: HotmartAffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartAffiliatesInclude<ExtArgs> | null
  }


  /**
   * Model HotmartBuyer
   */

  export type AggregateHotmartBuyer = {
    _count: HotmartBuyerCountAggregateOutputType | null
    _avg: HotmartBuyerAvgAggregateOutputType | null
    _sum: HotmartBuyerSumAggregateOutputType | null
    _min: HotmartBuyerMinAggregateOutputType | null
    _max: HotmartBuyerMaxAggregateOutputType | null
  }

  export type HotmartBuyerAvgAggregateOutputType = {
    id: number | null
  }

  export type HotmartBuyerSumAggregateOutputType = {
    id: number | null
  }

  export type HotmartBuyerMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    buyerEmail: string | null
    buyerDocument: string | null
    buyerName: string | null
    buyerCheckoutPhone: string | null
    buyerAddressCountryIso: string | null
    buyerAddressCountry: string | null
    buyerAddressZipCode: string | null
    buyerAddressState: string | null
    buyerAddressCity: string | null
    buyerAddressNeighborhood: string | null
    buyerAddressStreet: string | null
    buyerAddressComplement: string | null
    buyerAddressNumber: string | null
    lastOrderDate: Date | null
  }

  export type HotmartBuyerMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    buyerEmail: string | null
    buyerDocument: string | null
    buyerName: string | null
    buyerCheckoutPhone: string | null
    buyerAddressCountryIso: string | null
    buyerAddressCountry: string | null
    buyerAddressZipCode: string | null
    buyerAddressState: string | null
    buyerAddressCity: string | null
    buyerAddressNeighborhood: string | null
    buyerAddressStreet: string | null
    buyerAddressComplement: string | null
    buyerAddressNumber: string | null
    lastOrderDate: Date | null
  }

  export type HotmartBuyerCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    buyerEmail: number
    buyerDocument: number
    buyerName: number
    buyerCheckoutPhone: number
    buyerAddressCountryIso: number
    buyerAddressCountry: number
    buyerAddressZipCode: number
    buyerAddressState: number
    buyerAddressCity: number
    buyerAddressNeighborhood: number
    buyerAddressStreet: number
    buyerAddressComplement: number
    buyerAddressNumber: number
    lastOrderDate: number
    _all: number
  }


  export type HotmartBuyerAvgAggregateInputType = {
    id?: true
  }

  export type HotmartBuyerSumAggregateInputType = {
    id?: true
  }

  export type HotmartBuyerMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    buyerEmail?: true
    buyerDocument?: true
    buyerName?: true
    buyerCheckoutPhone?: true
    buyerAddressCountryIso?: true
    buyerAddressCountry?: true
    buyerAddressZipCode?: true
    buyerAddressState?: true
    buyerAddressCity?: true
    buyerAddressNeighborhood?: true
    buyerAddressStreet?: true
    buyerAddressComplement?: true
    buyerAddressNumber?: true
    lastOrderDate?: true
  }

  export type HotmartBuyerMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    buyerEmail?: true
    buyerDocument?: true
    buyerName?: true
    buyerCheckoutPhone?: true
    buyerAddressCountryIso?: true
    buyerAddressCountry?: true
    buyerAddressZipCode?: true
    buyerAddressState?: true
    buyerAddressCity?: true
    buyerAddressNeighborhood?: true
    buyerAddressStreet?: true
    buyerAddressComplement?: true
    buyerAddressNumber?: true
    lastOrderDate?: true
  }

  export type HotmartBuyerCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    buyerEmail?: true
    buyerDocument?: true
    buyerName?: true
    buyerCheckoutPhone?: true
    buyerAddressCountryIso?: true
    buyerAddressCountry?: true
    buyerAddressZipCode?: true
    buyerAddressState?: true
    buyerAddressCity?: true
    buyerAddressNeighborhood?: true
    buyerAddressStreet?: true
    buyerAddressComplement?: true
    buyerAddressNumber?: true
    lastOrderDate?: true
    _all?: true
  }

  export type HotmartBuyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartBuyer to aggregate.
     */
    where?: HotmartBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartBuyers to fetch.
     */
    orderBy?: HotmartBuyerOrderByWithRelationInput | HotmartBuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartBuyers
    **/
    _count?: true | HotmartBuyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartBuyerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartBuyerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartBuyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartBuyerMaxAggregateInputType
  }

  export type GetHotmartBuyerAggregateType<T extends HotmartBuyerAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartBuyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartBuyer[P]>
      : GetScalarType<T[P], AggregateHotmartBuyer[P]>
  }




  export type HotmartBuyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartBuyerWhereInput
    orderBy?: HotmartBuyerOrderByWithAggregationInput | HotmartBuyerOrderByWithAggregationInput[]
    by: HotmartBuyerScalarFieldEnum[] | HotmartBuyerScalarFieldEnum
    having?: HotmartBuyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartBuyerCountAggregateInputType | true
    _avg?: HotmartBuyerAvgAggregateInputType
    _sum?: HotmartBuyerSumAggregateInputType
    _min?: HotmartBuyerMinAggregateInputType
    _max?: HotmartBuyerMaxAggregateInputType
  }

  export type HotmartBuyerGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    buyerEmail: string
    buyerDocument: string | null
    buyerName: string | null
    buyerCheckoutPhone: string | null
    buyerAddressCountryIso: string | null
    buyerAddressCountry: string | null
    buyerAddressZipCode: string | null
    buyerAddressState: string | null
    buyerAddressCity: string | null
    buyerAddressNeighborhood: string | null
    buyerAddressStreet: string | null
    buyerAddressComplement: string | null
    buyerAddressNumber: string | null
    lastOrderDate: Date | null
    _count: HotmartBuyerCountAggregateOutputType | null
    _avg: HotmartBuyerAvgAggregateOutputType | null
    _sum: HotmartBuyerSumAggregateOutputType | null
    _min: HotmartBuyerMinAggregateOutputType | null
    _max: HotmartBuyerMaxAggregateOutputType | null
  }

  type GetHotmartBuyerGroupByPayload<T extends HotmartBuyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartBuyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartBuyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartBuyerGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartBuyerGroupByOutputType[P]>
        }
      >
    >


  export type HotmartBuyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    buyerEmail?: boolean
    buyerDocument?: boolean
    buyerName?: boolean
    buyerCheckoutPhone?: boolean
    buyerAddressCountryIso?: boolean
    buyerAddressCountry?: boolean
    buyerAddressZipCode?: boolean
    buyerAddressState?: boolean
    buyerAddressCity?: boolean
    buyerAddressNeighborhood?: boolean
    buyerAddressStreet?: boolean
    buyerAddressComplement?: boolean
    buyerAddressNumber?: boolean
    lastOrderDate?: boolean
    HotmartOrderNote?: boolean | HotmartBuyer$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartBuyerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartBuyer"]>

  export type HotmartBuyerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    buyerEmail?: boolean
    buyerDocument?: boolean
    buyerName?: boolean
    buyerCheckoutPhone?: boolean
    buyerAddressCountryIso?: boolean
    buyerAddressCountry?: boolean
    buyerAddressZipCode?: boolean
    buyerAddressState?: boolean
    buyerAddressCity?: boolean
    buyerAddressNeighborhood?: boolean
    buyerAddressStreet?: boolean
    buyerAddressComplement?: boolean
    buyerAddressNumber?: boolean
    lastOrderDate?: boolean
  }, ExtArgs["result"]["hotmartBuyer"]>

  export type HotmartBuyerSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    buyerEmail?: boolean
    buyerDocument?: boolean
    buyerName?: boolean
    buyerCheckoutPhone?: boolean
    buyerAddressCountryIso?: boolean
    buyerAddressCountry?: boolean
    buyerAddressZipCode?: boolean
    buyerAddressState?: boolean
    buyerAddressCity?: boolean
    buyerAddressNeighborhood?: boolean
    buyerAddressStreet?: boolean
    buyerAddressComplement?: boolean
    buyerAddressNumber?: boolean
    lastOrderDate?: boolean
  }

  export type HotmartBuyerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartBuyer$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartBuyerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotmartBuyerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotmartBuyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartBuyer"
    objects: {
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      buyerEmail: string
      buyerDocument: string | null
      buyerName: string | null
      buyerCheckoutPhone: string | null
      buyerAddressCountryIso: string | null
      buyerAddressCountry: string | null
      buyerAddressZipCode: string | null
      buyerAddressState: string | null
      buyerAddressCity: string | null
      buyerAddressNeighborhood: string | null
      buyerAddressStreet: string | null
      buyerAddressComplement: string | null
      buyerAddressNumber: string | null
      lastOrderDate: Date | null
    }, ExtArgs["result"]["hotmartBuyer"]>
    composites: {}
  }

  type HotmartBuyerGetPayload<S extends boolean | null | undefined | HotmartBuyerDefaultArgs> = $Result.GetResult<Prisma.$HotmartBuyerPayload, S>

  type HotmartBuyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartBuyerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartBuyerCountAggregateInputType | true
    }

  export interface HotmartBuyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartBuyer'], meta: { name: 'HotmartBuyer' } }
    /**
     * Find zero or one HotmartBuyer that matches the filter.
     * @param {HotmartBuyerFindUniqueArgs} args - Arguments to find a HotmartBuyer
     * @example
     * // Get one HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartBuyerFindUniqueArgs>(args: SelectSubset<T, HotmartBuyerFindUniqueArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartBuyer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartBuyerFindUniqueOrThrowArgs} args - Arguments to find a HotmartBuyer
     * @example
     * // Get one HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartBuyerFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartBuyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartBuyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerFindFirstArgs} args - Arguments to find a HotmartBuyer
     * @example
     * // Get one HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartBuyerFindFirstArgs>(args?: SelectSubset<T, HotmartBuyerFindFirstArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartBuyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerFindFirstOrThrowArgs} args - Arguments to find a HotmartBuyer
     * @example
     * // Get one HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartBuyerFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartBuyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartBuyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartBuyers
     * const hotmartBuyers = await prisma.hotmartBuyer.findMany()
     * 
     * // Get first 10 HotmartBuyers
     * const hotmartBuyers = await prisma.hotmartBuyer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartBuyerWithIdOnly = await prisma.hotmartBuyer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartBuyerFindManyArgs>(args?: SelectSubset<T, HotmartBuyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartBuyer.
     * @param {HotmartBuyerCreateArgs} args - Arguments to create a HotmartBuyer.
     * @example
     * // Create one HotmartBuyer
     * const HotmartBuyer = await prisma.hotmartBuyer.create({
     *   data: {
     *     // ... data to create a HotmartBuyer
     *   }
     * })
     * 
     */
    create<T extends HotmartBuyerCreateArgs>(args: SelectSubset<T, HotmartBuyerCreateArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartBuyers.
     * @param {HotmartBuyerCreateManyArgs} args - Arguments to create many HotmartBuyers.
     * @example
     * // Create many HotmartBuyers
     * const hotmartBuyer = await prisma.hotmartBuyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartBuyerCreateManyArgs>(args?: SelectSubset<T, HotmartBuyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartBuyers and returns the data saved in the database.
     * @param {HotmartBuyerCreateManyAndReturnArgs} args - Arguments to create many HotmartBuyers.
     * @example
     * // Create many HotmartBuyers
     * const hotmartBuyer = await prisma.hotmartBuyer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartBuyers and only return the `id`
     * const hotmartBuyerWithIdOnly = await prisma.hotmartBuyer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartBuyerCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartBuyerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartBuyer.
     * @param {HotmartBuyerDeleteArgs} args - Arguments to delete one HotmartBuyer.
     * @example
     * // Delete one HotmartBuyer
     * const HotmartBuyer = await prisma.hotmartBuyer.delete({
     *   where: {
     *     // ... filter to delete one HotmartBuyer
     *   }
     * })
     * 
     */
    delete<T extends HotmartBuyerDeleteArgs>(args: SelectSubset<T, HotmartBuyerDeleteArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartBuyer.
     * @param {HotmartBuyerUpdateArgs} args - Arguments to update one HotmartBuyer.
     * @example
     * // Update one HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartBuyerUpdateArgs>(args: SelectSubset<T, HotmartBuyerUpdateArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartBuyers.
     * @param {HotmartBuyerDeleteManyArgs} args - Arguments to filter HotmartBuyers to delete.
     * @example
     * // Delete a few HotmartBuyers
     * const { count } = await prisma.hotmartBuyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartBuyerDeleteManyArgs>(args?: SelectSubset<T, HotmartBuyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartBuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartBuyers
     * const hotmartBuyer = await prisma.hotmartBuyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartBuyerUpdateManyArgs>(args: SelectSubset<T, HotmartBuyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartBuyer.
     * @param {HotmartBuyerUpsertArgs} args - Arguments to update or create a HotmartBuyer.
     * @example
     * // Update or create a HotmartBuyer
     * const hotmartBuyer = await prisma.hotmartBuyer.upsert({
     *   create: {
     *     // ... data to create a HotmartBuyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartBuyer we want to update
     *   }
     * })
     */
    upsert<T extends HotmartBuyerUpsertArgs>(args: SelectSubset<T, HotmartBuyerUpsertArgs<ExtArgs>>): Prisma__HotmartBuyerClient<$Result.GetResult<Prisma.$HotmartBuyerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartBuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerCountArgs} args - Arguments to filter HotmartBuyers to count.
     * @example
     * // Count the number of HotmartBuyers
     * const count = await prisma.hotmartBuyer.count({
     *   where: {
     *     // ... the filter for the HotmartBuyers we want to count
     *   }
     * })
    **/
    count<T extends HotmartBuyerCountArgs>(
      args?: Subset<T, HotmartBuyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartBuyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartBuyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartBuyerAggregateArgs>(args: Subset<T, HotmartBuyerAggregateArgs>): Prisma.PrismaPromise<GetHotmartBuyerAggregateType<T>>

    /**
     * Group by HotmartBuyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartBuyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartBuyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartBuyerGroupByArgs['orderBy'] }
        : { orderBy?: HotmartBuyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartBuyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartBuyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartBuyer model
   */
  readonly fields: HotmartBuyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartBuyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartBuyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartOrderNote<T extends HotmartBuyer$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, HotmartBuyer$HotmartOrderNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartBuyer model
   */ 
  interface HotmartBuyerFieldRefs {
    readonly id: FieldRef<"HotmartBuyer", 'Int'>
    readonly creationDate: FieldRef<"HotmartBuyer", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartBuyer", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartBuyer", 'DateTime'>
    readonly buyerEmail: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerDocument: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerName: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerCheckoutPhone: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressCountryIso: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressCountry: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressZipCode: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressState: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressCity: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressNeighborhood: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressStreet: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressComplement: FieldRef<"HotmartBuyer", 'String'>
    readonly buyerAddressNumber: FieldRef<"HotmartBuyer", 'String'>
    readonly lastOrderDate: FieldRef<"HotmartBuyer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotmartBuyer findUnique
   */
  export type HotmartBuyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter, which HotmartBuyer to fetch.
     */
    where: HotmartBuyerWhereUniqueInput
  }

  /**
   * HotmartBuyer findUniqueOrThrow
   */
  export type HotmartBuyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter, which HotmartBuyer to fetch.
     */
    where: HotmartBuyerWhereUniqueInput
  }

  /**
   * HotmartBuyer findFirst
   */
  export type HotmartBuyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter, which HotmartBuyer to fetch.
     */
    where?: HotmartBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartBuyers to fetch.
     */
    orderBy?: HotmartBuyerOrderByWithRelationInput | HotmartBuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartBuyers.
     */
    cursor?: HotmartBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartBuyers.
     */
    distinct?: HotmartBuyerScalarFieldEnum | HotmartBuyerScalarFieldEnum[]
  }

  /**
   * HotmartBuyer findFirstOrThrow
   */
  export type HotmartBuyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter, which HotmartBuyer to fetch.
     */
    where?: HotmartBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartBuyers to fetch.
     */
    orderBy?: HotmartBuyerOrderByWithRelationInput | HotmartBuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartBuyers.
     */
    cursor?: HotmartBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartBuyers.
     */
    distinct?: HotmartBuyerScalarFieldEnum | HotmartBuyerScalarFieldEnum[]
  }

  /**
   * HotmartBuyer findMany
   */
  export type HotmartBuyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter, which HotmartBuyers to fetch.
     */
    where?: HotmartBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartBuyers to fetch.
     */
    orderBy?: HotmartBuyerOrderByWithRelationInput | HotmartBuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartBuyers.
     */
    cursor?: HotmartBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartBuyers.
     */
    skip?: number
    distinct?: HotmartBuyerScalarFieldEnum | HotmartBuyerScalarFieldEnum[]
  }

  /**
   * HotmartBuyer create
   */
  export type HotmartBuyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartBuyer.
     */
    data: XOR<HotmartBuyerCreateInput, HotmartBuyerUncheckedCreateInput>
  }

  /**
   * HotmartBuyer createMany
   */
  export type HotmartBuyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartBuyers.
     */
    data: HotmartBuyerCreateManyInput | HotmartBuyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartBuyer createManyAndReturn
   */
  export type HotmartBuyerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartBuyers.
     */
    data: HotmartBuyerCreateManyInput | HotmartBuyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartBuyer update
   */
  export type HotmartBuyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartBuyer.
     */
    data: XOR<HotmartBuyerUpdateInput, HotmartBuyerUncheckedUpdateInput>
    /**
     * Choose, which HotmartBuyer to update.
     */
    where: HotmartBuyerWhereUniqueInput
  }

  /**
   * HotmartBuyer updateMany
   */
  export type HotmartBuyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartBuyers.
     */
    data: XOR<HotmartBuyerUpdateManyMutationInput, HotmartBuyerUncheckedUpdateManyInput>
    /**
     * Filter which HotmartBuyers to update
     */
    where?: HotmartBuyerWhereInput
  }

  /**
   * HotmartBuyer upsert
   */
  export type HotmartBuyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartBuyer to update in case it exists.
     */
    where: HotmartBuyerWhereUniqueInput
    /**
     * In case the HotmartBuyer found by the `where` argument doesn't exist, create a new HotmartBuyer with this data.
     */
    create: XOR<HotmartBuyerCreateInput, HotmartBuyerUncheckedCreateInput>
    /**
     * In case the HotmartBuyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartBuyerUpdateInput, HotmartBuyerUncheckedUpdateInput>
  }

  /**
   * HotmartBuyer delete
   */
  export type HotmartBuyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
    /**
     * Filter which HotmartBuyer to delete.
     */
    where: HotmartBuyerWhereUniqueInput
  }

  /**
   * HotmartBuyer deleteMany
   */
  export type HotmartBuyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartBuyers to delete
     */
    where?: HotmartBuyerWhereInput
  }

  /**
   * HotmartBuyer.HotmartOrderNote
   */
  export type HotmartBuyer$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    cursor?: HotmartOrderNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartBuyer without action
   */
  export type HotmartBuyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartBuyer
     */
    select?: HotmartBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartBuyerInclude<ExtArgs> | null
  }


  /**
   * Model HotmartCommissions
   */

  export type AggregateHotmartCommissions = {
    _count: HotmartCommissionsCountAggregateOutputType | null
    _avg: HotmartCommissionsAvgAggregateOutputType | null
    _sum: HotmartCommissionsSumAggregateOutputType | null
    _min: HotmartCommissionsMinAggregateOutputType | null
    _max: HotmartCommissionsMaxAggregateOutputType | null
  }

  export type HotmartCommissionsAvgAggregateOutputType = {
    id: number | null
    value: Decimal | null
    convertedvalue: Decimal | null
    currencyConvertionRate: Decimal | null
    hotmartPurchaseId: number | null
  }

  export type HotmartCommissionsSumAggregateOutputType = {
    id: number | null
    value: Decimal | null
    convertedvalue: Decimal | null
    currencyConvertionRate: Decimal | null
    hotmartPurchaseId: number | null
  }

  export type HotmartCommissionsMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    sourceName: string | null
    value: Decimal | null
    currencyValue: string | null
    convertedToCurrency: string | null
    convertedvalue: Decimal | null
    currencyConvertionRate: Decimal | null
    hotmartPurchaseId: number | null
  }

  export type HotmartCommissionsMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    sourceName: string | null
    value: Decimal | null
    currencyValue: string | null
    convertedToCurrency: string | null
    convertedvalue: Decimal | null
    currencyConvertionRate: Decimal | null
    hotmartPurchaseId: number | null
  }

  export type HotmartCommissionsCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    sourceName: number
    value: number
    currencyValue: number
    convertedToCurrency: number
    convertedvalue: number
    currencyConvertionRate: number
    hotmartPurchaseId: number
    _all: number
  }


  export type HotmartCommissionsAvgAggregateInputType = {
    id?: true
    value?: true
    convertedvalue?: true
    currencyConvertionRate?: true
    hotmartPurchaseId?: true
  }

  export type HotmartCommissionsSumAggregateInputType = {
    id?: true
    value?: true
    convertedvalue?: true
    currencyConvertionRate?: true
    hotmartPurchaseId?: true
  }

  export type HotmartCommissionsMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    sourceName?: true
    value?: true
    currencyValue?: true
    convertedToCurrency?: true
    convertedvalue?: true
    currencyConvertionRate?: true
    hotmartPurchaseId?: true
  }

  export type HotmartCommissionsMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    sourceName?: true
    value?: true
    currencyValue?: true
    convertedToCurrency?: true
    convertedvalue?: true
    currencyConvertionRate?: true
    hotmartPurchaseId?: true
  }

  export type HotmartCommissionsCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    sourceName?: true
    value?: true
    currencyValue?: true
    convertedToCurrency?: true
    convertedvalue?: true
    currencyConvertionRate?: true
    hotmartPurchaseId?: true
    _all?: true
  }

  export type HotmartCommissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartCommissions to aggregate.
     */
    where?: HotmartCommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartCommissions to fetch.
     */
    orderBy?: HotmartCommissionsOrderByWithRelationInput | HotmartCommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartCommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartCommissions
    **/
    _count?: true | HotmartCommissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartCommissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartCommissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartCommissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartCommissionsMaxAggregateInputType
  }

  export type GetHotmartCommissionsAggregateType<T extends HotmartCommissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartCommissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartCommissions[P]>
      : GetScalarType<T[P], AggregateHotmartCommissions[P]>
  }




  export type HotmartCommissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartCommissionsWhereInput
    orderBy?: HotmartCommissionsOrderByWithAggregationInput | HotmartCommissionsOrderByWithAggregationInput[]
    by: HotmartCommissionsScalarFieldEnum[] | HotmartCommissionsScalarFieldEnum
    having?: HotmartCommissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartCommissionsCountAggregateInputType | true
    _avg?: HotmartCommissionsAvgAggregateInputType
    _sum?: HotmartCommissionsSumAggregateInputType
    _min?: HotmartCommissionsMinAggregateInputType
    _max?: HotmartCommissionsMaxAggregateInputType
  }

  export type HotmartCommissionsGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    sourceName: string | null
    value: Decimal | null
    currencyValue: string | null
    convertedToCurrency: string | null
    convertedvalue: Decimal | null
    currencyConvertionRate: Decimal | null
    hotmartPurchaseId: number | null
    _count: HotmartCommissionsCountAggregateOutputType | null
    _avg: HotmartCommissionsAvgAggregateOutputType | null
    _sum: HotmartCommissionsSumAggregateOutputType | null
    _min: HotmartCommissionsMinAggregateOutputType | null
    _max: HotmartCommissionsMaxAggregateOutputType | null
  }

  type GetHotmartCommissionsGroupByPayload<T extends HotmartCommissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartCommissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartCommissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartCommissionsGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartCommissionsGroupByOutputType[P]>
        }
      >
    >


  export type HotmartCommissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    sourceName?: boolean
    value?: boolean
    currencyValue?: boolean
    convertedToCurrency?: boolean
    convertedvalue?: boolean
    currencyConvertionRate?: boolean
    hotmartPurchaseId?: boolean
    HotmartPurchase?: boolean | HotmartCommissions$HotmartPurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartCommissions"]>

  export type HotmartCommissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    sourceName?: boolean
    value?: boolean
    currencyValue?: boolean
    convertedToCurrency?: boolean
    convertedvalue?: boolean
    currencyConvertionRate?: boolean
    hotmartPurchaseId?: boolean
    HotmartPurchase?: boolean | HotmartCommissions$HotmartPurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartCommissions"]>

  export type HotmartCommissionsSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    sourceName?: boolean
    value?: boolean
    currencyValue?: boolean
    convertedToCurrency?: boolean
    convertedvalue?: boolean
    currencyConvertionRate?: boolean
    hotmartPurchaseId?: boolean
  }

  export type HotmartCommissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartPurchase?: boolean | HotmartCommissions$HotmartPurchaseArgs<ExtArgs>
  }
  export type HotmartCommissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartPurchase?: boolean | HotmartCommissions$HotmartPurchaseArgs<ExtArgs>
  }

  export type $HotmartCommissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartCommissions"
    objects: {
      HotmartPurchase: Prisma.$HotmartPurchasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      sourceName: string | null
      value: Prisma.Decimal | null
      currencyValue: string | null
      convertedToCurrency: string | null
      convertedvalue: Prisma.Decimal | null
      currencyConvertionRate: Prisma.Decimal | null
      hotmartPurchaseId: number | null
    }, ExtArgs["result"]["hotmartCommissions"]>
    composites: {}
  }

  type HotmartCommissionsGetPayload<S extends boolean | null | undefined | HotmartCommissionsDefaultArgs> = $Result.GetResult<Prisma.$HotmartCommissionsPayload, S>

  type HotmartCommissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartCommissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartCommissionsCountAggregateInputType | true
    }

  export interface HotmartCommissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartCommissions'], meta: { name: 'HotmartCommissions' } }
    /**
     * Find zero or one HotmartCommissions that matches the filter.
     * @param {HotmartCommissionsFindUniqueArgs} args - Arguments to find a HotmartCommissions
     * @example
     * // Get one HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartCommissionsFindUniqueArgs>(args: SelectSubset<T, HotmartCommissionsFindUniqueArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartCommissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartCommissionsFindUniqueOrThrowArgs} args - Arguments to find a HotmartCommissions
     * @example
     * // Get one HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartCommissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartCommissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsFindFirstArgs} args - Arguments to find a HotmartCommissions
     * @example
     * // Get one HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartCommissionsFindFirstArgs>(args?: SelectSubset<T, HotmartCommissionsFindFirstArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartCommissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsFindFirstOrThrowArgs} args - Arguments to find a HotmartCommissions
     * @example
     * // Get one HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartCommissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartCommissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartCommissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findMany()
     * 
     * // Get first 10 HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartCommissionsWithIdOnly = await prisma.hotmartCommissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartCommissionsFindManyArgs>(args?: SelectSubset<T, HotmartCommissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartCommissions.
     * @param {HotmartCommissionsCreateArgs} args - Arguments to create a HotmartCommissions.
     * @example
     * // Create one HotmartCommissions
     * const HotmartCommissions = await prisma.hotmartCommissions.create({
     *   data: {
     *     // ... data to create a HotmartCommissions
     *   }
     * })
     * 
     */
    create<T extends HotmartCommissionsCreateArgs>(args: SelectSubset<T, HotmartCommissionsCreateArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartCommissions.
     * @param {HotmartCommissionsCreateManyArgs} args - Arguments to create many HotmartCommissions.
     * @example
     * // Create many HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartCommissionsCreateManyArgs>(args?: SelectSubset<T, HotmartCommissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartCommissions and returns the data saved in the database.
     * @param {HotmartCommissionsCreateManyAndReturnArgs} args - Arguments to create many HotmartCommissions.
     * @example
     * // Create many HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartCommissions and only return the `id`
     * const hotmartCommissionsWithIdOnly = await prisma.hotmartCommissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartCommissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartCommissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartCommissions.
     * @param {HotmartCommissionsDeleteArgs} args - Arguments to delete one HotmartCommissions.
     * @example
     * // Delete one HotmartCommissions
     * const HotmartCommissions = await prisma.hotmartCommissions.delete({
     *   where: {
     *     // ... filter to delete one HotmartCommissions
     *   }
     * })
     * 
     */
    delete<T extends HotmartCommissionsDeleteArgs>(args: SelectSubset<T, HotmartCommissionsDeleteArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartCommissions.
     * @param {HotmartCommissionsUpdateArgs} args - Arguments to update one HotmartCommissions.
     * @example
     * // Update one HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartCommissionsUpdateArgs>(args: SelectSubset<T, HotmartCommissionsUpdateArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartCommissions.
     * @param {HotmartCommissionsDeleteManyArgs} args - Arguments to filter HotmartCommissions to delete.
     * @example
     * // Delete a few HotmartCommissions
     * const { count } = await prisma.hotmartCommissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartCommissionsDeleteManyArgs>(args?: SelectSubset<T, HotmartCommissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartCommissionsUpdateManyArgs>(args: SelectSubset<T, HotmartCommissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartCommissions.
     * @param {HotmartCommissionsUpsertArgs} args - Arguments to update or create a HotmartCommissions.
     * @example
     * // Update or create a HotmartCommissions
     * const hotmartCommissions = await prisma.hotmartCommissions.upsert({
     *   create: {
     *     // ... data to create a HotmartCommissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartCommissions we want to update
     *   }
     * })
     */
    upsert<T extends HotmartCommissionsUpsertArgs>(args: SelectSubset<T, HotmartCommissionsUpsertArgs<ExtArgs>>): Prisma__HotmartCommissionsClient<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsCountArgs} args - Arguments to filter HotmartCommissions to count.
     * @example
     * // Count the number of HotmartCommissions
     * const count = await prisma.hotmartCommissions.count({
     *   where: {
     *     // ... the filter for the HotmartCommissions we want to count
     *   }
     * })
    **/
    count<T extends HotmartCommissionsCountArgs>(
      args?: Subset<T, HotmartCommissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartCommissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartCommissionsAggregateArgs>(args: Subset<T, HotmartCommissionsAggregateArgs>): Prisma.PrismaPromise<GetHotmartCommissionsAggregateType<T>>

    /**
     * Group by HotmartCommissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartCommissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartCommissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartCommissionsGroupByArgs['orderBy'] }
        : { orderBy?: HotmartCommissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartCommissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartCommissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartCommissions model
   */
  readonly fields: HotmartCommissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartCommissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartCommissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartPurchase<T extends HotmartCommissions$HotmartPurchaseArgs<ExtArgs> = {}>(args?: Subset<T, HotmartCommissions$HotmartPurchaseArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartCommissions model
   */ 
  interface HotmartCommissionsFieldRefs {
    readonly id: FieldRef<"HotmartCommissions", 'Int'>
    readonly creationDate: FieldRef<"HotmartCommissions", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartCommissions", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartCommissions", 'DateTime'>
    readonly sourceName: FieldRef<"HotmartCommissions", 'String'>
    readonly value: FieldRef<"HotmartCommissions", 'Decimal'>
    readonly currencyValue: FieldRef<"HotmartCommissions", 'String'>
    readonly convertedToCurrency: FieldRef<"HotmartCommissions", 'String'>
    readonly convertedvalue: FieldRef<"HotmartCommissions", 'Decimal'>
    readonly currencyConvertionRate: FieldRef<"HotmartCommissions", 'Decimal'>
    readonly hotmartPurchaseId: FieldRef<"HotmartCommissions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotmartCommissions findUnique
   */
  export type HotmartCommissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter, which HotmartCommissions to fetch.
     */
    where: HotmartCommissionsWhereUniqueInput
  }

  /**
   * HotmartCommissions findUniqueOrThrow
   */
  export type HotmartCommissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter, which HotmartCommissions to fetch.
     */
    where: HotmartCommissionsWhereUniqueInput
  }

  /**
   * HotmartCommissions findFirst
   */
  export type HotmartCommissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter, which HotmartCommissions to fetch.
     */
    where?: HotmartCommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartCommissions to fetch.
     */
    orderBy?: HotmartCommissionsOrderByWithRelationInput | HotmartCommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartCommissions.
     */
    cursor?: HotmartCommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartCommissions.
     */
    distinct?: HotmartCommissionsScalarFieldEnum | HotmartCommissionsScalarFieldEnum[]
  }

  /**
   * HotmartCommissions findFirstOrThrow
   */
  export type HotmartCommissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter, which HotmartCommissions to fetch.
     */
    where?: HotmartCommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartCommissions to fetch.
     */
    orderBy?: HotmartCommissionsOrderByWithRelationInput | HotmartCommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartCommissions.
     */
    cursor?: HotmartCommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartCommissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartCommissions.
     */
    distinct?: HotmartCommissionsScalarFieldEnum | HotmartCommissionsScalarFieldEnum[]
  }

  /**
   * HotmartCommissions findMany
   */
  export type HotmartCommissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter, which HotmartCommissions to fetch.
     */
    where?: HotmartCommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartCommissions to fetch.
     */
    orderBy?: HotmartCommissionsOrderByWithRelationInput | HotmartCommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartCommissions.
     */
    cursor?: HotmartCommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartCommissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartCommissions.
     */
    skip?: number
    distinct?: HotmartCommissionsScalarFieldEnum | HotmartCommissionsScalarFieldEnum[]
  }

  /**
   * HotmartCommissions create
   */
  export type HotmartCommissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartCommissions.
     */
    data: XOR<HotmartCommissionsCreateInput, HotmartCommissionsUncheckedCreateInput>
  }

  /**
   * HotmartCommissions createMany
   */
  export type HotmartCommissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartCommissions.
     */
    data: HotmartCommissionsCreateManyInput | HotmartCommissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartCommissions createManyAndReturn
   */
  export type HotmartCommissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartCommissions.
     */
    data: HotmartCommissionsCreateManyInput | HotmartCommissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotmartCommissions update
   */
  export type HotmartCommissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartCommissions.
     */
    data: XOR<HotmartCommissionsUpdateInput, HotmartCommissionsUncheckedUpdateInput>
    /**
     * Choose, which HotmartCommissions to update.
     */
    where: HotmartCommissionsWhereUniqueInput
  }

  /**
   * HotmartCommissions updateMany
   */
  export type HotmartCommissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartCommissions.
     */
    data: XOR<HotmartCommissionsUpdateManyMutationInput, HotmartCommissionsUncheckedUpdateManyInput>
    /**
     * Filter which HotmartCommissions to update
     */
    where?: HotmartCommissionsWhereInput
  }

  /**
   * HotmartCommissions upsert
   */
  export type HotmartCommissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartCommissions to update in case it exists.
     */
    where: HotmartCommissionsWhereUniqueInput
    /**
     * In case the HotmartCommissions found by the `where` argument doesn't exist, create a new HotmartCommissions with this data.
     */
    create: XOR<HotmartCommissionsCreateInput, HotmartCommissionsUncheckedCreateInput>
    /**
     * In case the HotmartCommissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartCommissionsUpdateInput, HotmartCommissionsUncheckedUpdateInput>
  }

  /**
   * HotmartCommissions delete
   */
  export type HotmartCommissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    /**
     * Filter which HotmartCommissions to delete.
     */
    where: HotmartCommissionsWhereUniqueInput
  }

  /**
   * HotmartCommissions deleteMany
   */
  export type HotmartCommissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartCommissions to delete
     */
    where?: HotmartCommissionsWhereInput
  }

  /**
   * HotmartCommissions.HotmartPurchase
   */
  export type HotmartCommissions$HotmartPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    where?: HotmartPurchaseWhereInput
  }

  /**
   * HotmartCommissions without action
   */
  export type HotmartCommissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
  }


  /**
   * Model HotmartPurchase
   */

  export type AggregateHotmartPurchase = {
    _count: HotmartPurchaseCountAggregateOutputType | null
    _avg: HotmartPurchaseAvgAggregateOutputType | null
    _sum: HotmartPurchaseSumAggregateOutputType | null
    _min: HotmartPurchaseMinAggregateOutputType | null
    _max: HotmartPurchaseMaxAggregateOutputType | null
  }

  export type HotmartPurchaseAvgAggregateOutputType = {
    id: number | null
    fullPriceValue: Decimal | null
    originalPriceValue: Decimal | null
    priceValue: Decimal | null
    recurrencyNumber: number | null
  }

  export type HotmartPurchaseSumAggregateOutputType = {
    id: number | null
    fullPriceValue: Decimal | null
    originalPriceValue: Decimal | null
    priceValue: Decimal | null
    recurrencyNumber: number | null
  }

  export type HotmartPurchaseMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    orderDate: Date | null
    approvedDate: Date | null
    transactionId: string | null
    status: string | null
    fullPriceValue: Decimal | null
    fullPriceCurrency: string | null
    originalPriceValue: Decimal | null
    originalPriceCurrency: string | null
    priceValue: Decimal | null
    priceCurrency: string | null
    offerCode: string | null
    recurrencyNumber: number | null
    subscriptionAnticipationPurchase: boolean | null
    checkoutCountryName: string | null
    checkoutCountryISO: string | null
    utmCode: string | null
    isOrderBump: boolean | null
    originalTransactionId: string | null
    nextChargeDate: Date | null
  }

  export type HotmartPurchaseMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    orderDate: Date | null
    approvedDate: Date | null
    transactionId: string | null
    status: string | null
    fullPriceValue: Decimal | null
    fullPriceCurrency: string | null
    originalPriceValue: Decimal | null
    originalPriceCurrency: string | null
    priceValue: Decimal | null
    priceCurrency: string | null
    offerCode: string | null
    recurrencyNumber: number | null
    subscriptionAnticipationPurchase: boolean | null
    checkoutCountryName: string | null
    checkoutCountryISO: string | null
    utmCode: string | null
    isOrderBump: boolean | null
    originalTransactionId: string | null
    nextChargeDate: Date | null
  }

  export type HotmartPurchaseCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    orderDate: number
    approvedDate: number
    transactionId: number
    status: number
    fullPriceValue: number
    fullPriceCurrency: number
    originalPriceValue: number
    originalPriceCurrency: number
    priceValue: number
    priceCurrency: number
    offerCode: number
    recurrencyNumber: number
    subscriptionAnticipationPurchase: number
    checkoutCountryName: number
    checkoutCountryISO: number
    utmCode: number
    isOrderBump: number
    originalTransactionId: number
    nextChargeDate: number
    _all: number
  }


  export type HotmartPurchaseAvgAggregateInputType = {
    id?: true
    fullPriceValue?: true
    originalPriceValue?: true
    priceValue?: true
    recurrencyNumber?: true
  }

  export type HotmartPurchaseSumAggregateInputType = {
    id?: true
    fullPriceValue?: true
    originalPriceValue?: true
    priceValue?: true
    recurrencyNumber?: true
  }

  export type HotmartPurchaseMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    orderDate?: true
    approvedDate?: true
    transactionId?: true
    status?: true
    fullPriceValue?: true
    fullPriceCurrency?: true
    originalPriceValue?: true
    originalPriceCurrency?: true
    priceValue?: true
    priceCurrency?: true
    offerCode?: true
    recurrencyNumber?: true
    subscriptionAnticipationPurchase?: true
    checkoutCountryName?: true
    checkoutCountryISO?: true
    utmCode?: true
    isOrderBump?: true
    originalTransactionId?: true
    nextChargeDate?: true
  }

  export type HotmartPurchaseMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    orderDate?: true
    approvedDate?: true
    transactionId?: true
    status?: true
    fullPriceValue?: true
    fullPriceCurrency?: true
    originalPriceValue?: true
    originalPriceCurrency?: true
    priceValue?: true
    priceCurrency?: true
    offerCode?: true
    recurrencyNumber?: true
    subscriptionAnticipationPurchase?: true
    checkoutCountryName?: true
    checkoutCountryISO?: true
    utmCode?: true
    isOrderBump?: true
    originalTransactionId?: true
    nextChargeDate?: true
  }

  export type HotmartPurchaseCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    orderDate?: true
    approvedDate?: true
    transactionId?: true
    status?: true
    fullPriceValue?: true
    fullPriceCurrency?: true
    originalPriceValue?: true
    originalPriceCurrency?: true
    priceValue?: true
    priceCurrency?: true
    offerCode?: true
    recurrencyNumber?: true
    subscriptionAnticipationPurchase?: true
    checkoutCountryName?: true
    checkoutCountryISO?: true
    utmCode?: true
    isOrderBump?: true
    originalTransactionId?: true
    nextChargeDate?: true
    _all?: true
  }

  export type HotmartPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartPurchase to aggregate.
     */
    where?: HotmartPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPurchases to fetch.
     */
    orderBy?: HotmartPurchaseOrderByWithRelationInput | HotmartPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartPurchases
    **/
    _count?: true | HotmartPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartPurchaseMaxAggregateInputType
  }

  export type GetHotmartPurchaseAggregateType<T extends HotmartPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartPurchase[P]>
      : GetScalarType<T[P], AggregateHotmartPurchase[P]>
  }




  export type HotmartPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartPurchaseWhereInput
    orderBy?: HotmartPurchaseOrderByWithAggregationInput | HotmartPurchaseOrderByWithAggregationInput[]
    by: HotmartPurchaseScalarFieldEnum[] | HotmartPurchaseScalarFieldEnum
    having?: HotmartPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartPurchaseCountAggregateInputType | true
    _avg?: HotmartPurchaseAvgAggregateInputType
    _sum?: HotmartPurchaseSumAggregateInputType
    _min?: HotmartPurchaseMinAggregateInputType
    _max?: HotmartPurchaseMaxAggregateInputType
  }

  export type HotmartPurchaseGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    orderDate: Date
    approvedDate: Date
    transactionId: string
    status: string
    fullPriceValue: Decimal
    fullPriceCurrency: string
    originalPriceValue: Decimal
    originalPriceCurrency: string
    priceValue: Decimal
    priceCurrency: string
    offerCode: string
    recurrencyNumber: number | null
    subscriptionAnticipationPurchase: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode: string | null
    isOrderBump: boolean | null
    originalTransactionId: string | null
    nextChargeDate: Date | null
    _count: HotmartPurchaseCountAggregateOutputType | null
    _avg: HotmartPurchaseAvgAggregateOutputType | null
    _sum: HotmartPurchaseSumAggregateOutputType | null
    _min: HotmartPurchaseMinAggregateOutputType | null
    _max: HotmartPurchaseMaxAggregateOutputType | null
  }

  type GetHotmartPurchaseGroupByPayload<T extends HotmartPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type HotmartPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    orderDate?: boolean
    approvedDate?: boolean
    transactionId?: boolean
    status?: boolean
    fullPriceValue?: boolean
    fullPriceCurrency?: boolean
    originalPriceValue?: boolean
    originalPriceCurrency?: boolean
    priceValue?: boolean
    priceCurrency?: boolean
    offerCode?: boolean
    recurrencyNumber?: boolean
    subscriptionAnticipationPurchase?: boolean
    checkoutCountryName?: boolean
    checkoutCountryISO?: boolean
    utmCode?: boolean
    isOrderBump?: boolean
    originalTransactionId?: boolean
    nextChargeDate?: boolean
    hotmartPaymentInfos?: boolean | HotmartPurchase$hotmartPaymentInfosArgs<ExtArgs>
    hotmartCommissions?: boolean | HotmartPurchase$hotmartCommissionsArgs<ExtArgs>
    HotmartOrderNote?: boolean | HotmartPurchase$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartPurchase"]>

  export type HotmartPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    orderDate?: boolean
    approvedDate?: boolean
    transactionId?: boolean
    status?: boolean
    fullPriceValue?: boolean
    fullPriceCurrency?: boolean
    originalPriceValue?: boolean
    originalPriceCurrency?: boolean
    priceValue?: boolean
    priceCurrency?: boolean
    offerCode?: boolean
    recurrencyNumber?: boolean
    subscriptionAnticipationPurchase?: boolean
    checkoutCountryName?: boolean
    checkoutCountryISO?: boolean
    utmCode?: boolean
    isOrderBump?: boolean
    originalTransactionId?: boolean
    nextChargeDate?: boolean
  }, ExtArgs["result"]["hotmartPurchase"]>

  export type HotmartPurchaseSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    orderDate?: boolean
    approvedDate?: boolean
    transactionId?: boolean
    status?: boolean
    fullPriceValue?: boolean
    fullPriceCurrency?: boolean
    originalPriceValue?: boolean
    originalPriceCurrency?: boolean
    priceValue?: boolean
    priceCurrency?: boolean
    offerCode?: boolean
    recurrencyNumber?: boolean
    subscriptionAnticipationPurchase?: boolean
    checkoutCountryName?: boolean
    checkoutCountryISO?: boolean
    utmCode?: boolean
    isOrderBump?: boolean
    originalTransactionId?: boolean
    nextChargeDate?: boolean
  }

  export type HotmartPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotmartPaymentInfos?: boolean | HotmartPurchase$hotmartPaymentInfosArgs<ExtArgs>
    hotmartCommissions?: boolean | HotmartPurchase$hotmartCommissionsArgs<ExtArgs>
    HotmartOrderNote?: boolean | HotmartPurchase$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotmartPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotmartPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartPurchase"
    objects: {
      hotmartPaymentInfos: Prisma.$HotmartPaymentInfosPayload<ExtArgs>[]
      hotmartCommissions: Prisma.$HotmartCommissionsPayload<ExtArgs>[]
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      orderDate: Date
      approvedDate: Date
      transactionId: string
      status: string
      fullPriceValue: Prisma.Decimal
      fullPriceCurrency: string
      originalPriceValue: Prisma.Decimal
      originalPriceCurrency: string
      priceValue: Prisma.Decimal
      priceCurrency: string
      offerCode: string
      recurrencyNumber: number | null
      subscriptionAnticipationPurchase: boolean | null
      checkoutCountryName: string
      checkoutCountryISO: string
      utmCode: string | null
      isOrderBump: boolean | null
      originalTransactionId: string | null
      nextChargeDate: Date | null
    }, ExtArgs["result"]["hotmartPurchase"]>
    composites: {}
  }

  type HotmartPurchaseGetPayload<S extends boolean | null | undefined | HotmartPurchaseDefaultArgs> = $Result.GetResult<Prisma.$HotmartPurchasePayload, S>

  type HotmartPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartPurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartPurchaseCountAggregateInputType | true
    }

  export interface HotmartPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartPurchase'], meta: { name: 'HotmartPurchase' } }
    /**
     * Find zero or one HotmartPurchase that matches the filter.
     * @param {HotmartPurchaseFindUniqueArgs} args - Arguments to find a HotmartPurchase
     * @example
     * // Get one HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartPurchaseFindUniqueArgs>(args: SelectSubset<T, HotmartPurchaseFindUniqueArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartPurchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartPurchaseFindUniqueOrThrowArgs} args - Arguments to find a HotmartPurchase
     * @example
     * // Get one HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseFindFirstArgs} args - Arguments to find a HotmartPurchase
     * @example
     * // Get one HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartPurchaseFindFirstArgs>(args?: SelectSubset<T, HotmartPurchaseFindFirstArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseFindFirstOrThrowArgs} args - Arguments to find a HotmartPurchase
     * @example
     * // Get one HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartPurchases
     * const hotmartPurchases = await prisma.hotmartPurchase.findMany()
     * 
     * // Get first 10 HotmartPurchases
     * const hotmartPurchases = await prisma.hotmartPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartPurchaseWithIdOnly = await prisma.hotmartPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartPurchaseFindManyArgs>(args?: SelectSubset<T, HotmartPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartPurchase.
     * @param {HotmartPurchaseCreateArgs} args - Arguments to create a HotmartPurchase.
     * @example
     * // Create one HotmartPurchase
     * const HotmartPurchase = await prisma.hotmartPurchase.create({
     *   data: {
     *     // ... data to create a HotmartPurchase
     *   }
     * })
     * 
     */
    create<T extends HotmartPurchaseCreateArgs>(args: SelectSubset<T, HotmartPurchaseCreateArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartPurchases.
     * @param {HotmartPurchaseCreateManyArgs} args - Arguments to create many HotmartPurchases.
     * @example
     * // Create many HotmartPurchases
     * const hotmartPurchase = await prisma.hotmartPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartPurchaseCreateManyArgs>(args?: SelectSubset<T, HotmartPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartPurchases and returns the data saved in the database.
     * @param {HotmartPurchaseCreateManyAndReturnArgs} args - Arguments to create many HotmartPurchases.
     * @example
     * // Create many HotmartPurchases
     * const hotmartPurchase = await prisma.hotmartPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartPurchases and only return the `id`
     * const hotmartPurchaseWithIdOnly = await prisma.hotmartPurchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartPurchase.
     * @param {HotmartPurchaseDeleteArgs} args - Arguments to delete one HotmartPurchase.
     * @example
     * // Delete one HotmartPurchase
     * const HotmartPurchase = await prisma.hotmartPurchase.delete({
     *   where: {
     *     // ... filter to delete one HotmartPurchase
     *   }
     * })
     * 
     */
    delete<T extends HotmartPurchaseDeleteArgs>(args: SelectSubset<T, HotmartPurchaseDeleteArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartPurchase.
     * @param {HotmartPurchaseUpdateArgs} args - Arguments to update one HotmartPurchase.
     * @example
     * // Update one HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartPurchaseUpdateArgs>(args: SelectSubset<T, HotmartPurchaseUpdateArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartPurchases.
     * @param {HotmartPurchaseDeleteManyArgs} args - Arguments to filter HotmartPurchases to delete.
     * @example
     * // Delete a few HotmartPurchases
     * const { count } = await prisma.hotmartPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartPurchaseDeleteManyArgs>(args?: SelectSubset<T, HotmartPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartPurchases
     * const hotmartPurchase = await prisma.hotmartPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartPurchaseUpdateManyArgs>(args: SelectSubset<T, HotmartPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartPurchase.
     * @param {HotmartPurchaseUpsertArgs} args - Arguments to update or create a HotmartPurchase.
     * @example
     * // Update or create a HotmartPurchase
     * const hotmartPurchase = await prisma.hotmartPurchase.upsert({
     *   create: {
     *     // ... data to create a HotmartPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartPurchase we want to update
     *   }
     * })
     */
    upsert<T extends HotmartPurchaseUpsertArgs>(args: SelectSubset<T, HotmartPurchaseUpsertArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseCountArgs} args - Arguments to filter HotmartPurchases to count.
     * @example
     * // Count the number of HotmartPurchases
     * const count = await prisma.hotmartPurchase.count({
     *   where: {
     *     // ... the filter for the HotmartPurchases we want to count
     *   }
     * })
    **/
    count<T extends HotmartPurchaseCountArgs>(
      args?: Subset<T, HotmartPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartPurchaseAggregateArgs>(args: Subset<T, HotmartPurchaseAggregateArgs>): Prisma.PrismaPromise<GetHotmartPurchaseAggregateType<T>>

    /**
     * Group by HotmartPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: HotmartPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartPurchase model
   */
  readonly fields: HotmartPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotmartPaymentInfos<T extends HotmartPurchase$hotmartPaymentInfosArgs<ExtArgs> = {}>(args?: Subset<T, HotmartPurchase$hotmartPaymentInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findMany"> | Null>
    hotmartCommissions<T extends HotmartPurchase$hotmartCommissionsArgs<ExtArgs> = {}>(args?: Subset<T, HotmartPurchase$hotmartCommissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartCommissionsPayload<ExtArgs>, T, "findMany"> | Null>
    HotmartOrderNote<T extends HotmartPurchase$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, HotmartPurchase$HotmartOrderNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartPurchase model
   */ 
  interface HotmartPurchaseFieldRefs {
    readonly id: FieldRef<"HotmartPurchase", 'Int'>
    readonly creationDate: FieldRef<"HotmartPurchase", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartPurchase", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartPurchase", 'DateTime'>
    readonly orderDate: FieldRef<"HotmartPurchase", 'DateTime'>
    readonly approvedDate: FieldRef<"HotmartPurchase", 'DateTime'>
    readonly transactionId: FieldRef<"HotmartPurchase", 'String'>
    readonly status: FieldRef<"HotmartPurchase", 'String'>
    readonly fullPriceValue: FieldRef<"HotmartPurchase", 'Decimal'>
    readonly fullPriceCurrency: FieldRef<"HotmartPurchase", 'String'>
    readonly originalPriceValue: FieldRef<"HotmartPurchase", 'Decimal'>
    readonly originalPriceCurrency: FieldRef<"HotmartPurchase", 'String'>
    readonly priceValue: FieldRef<"HotmartPurchase", 'Decimal'>
    readonly priceCurrency: FieldRef<"HotmartPurchase", 'String'>
    readonly offerCode: FieldRef<"HotmartPurchase", 'String'>
    readonly recurrencyNumber: FieldRef<"HotmartPurchase", 'Int'>
    readonly subscriptionAnticipationPurchase: FieldRef<"HotmartPurchase", 'Boolean'>
    readonly checkoutCountryName: FieldRef<"HotmartPurchase", 'String'>
    readonly checkoutCountryISO: FieldRef<"HotmartPurchase", 'String'>
    readonly utmCode: FieldRef<"HotmartPurchase", 'String'>
    readonly isOrderBump: FieldRef<"HotmartPurchase", 'Boolean'>
    readonly originalTransactionId: FieldRef<"HotmartPurchase", 'String'>
    readonly nextChargeDate: FieldRef<"HotmartPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotmartPurchase findUnique
   */
  export type HotmartPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPurchase to fetch.
     */
    where: HotmartPurchaseWhereUniqueInput
  }

  /**
   * HotmartPurchase findUniqueOrThrow
   */
  export type HotmartPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPurchase to fetch.
     */
    where: HotmartPurchaseWhereUniqueInput
  }

  /**
   * HotmartPurchase findFirst
   */
  export type HotmartPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPurchase to fetch.
     */
    where?: HotmartPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPurchases to fetch.
     */
    orderBy?: HotmartPurchaseOrderByWithRelationInput | HotmartPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartPurchases.
     */
    cursor?: HotmartPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartPurchases.
     */
    distinct?: HotmartPurchaseScalarFieldEnum | HotmartPurchaseScalarFieldEnum[]
  }

  /**
   * HotmartPurchase findFirstOrThrow
   */
  export type HotmartPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPurchase to fetch.
     */
    where?: HotmartPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPurchases to fetch.
     */
    orderBy?: HotmartPurchaseOrderByWithRelationInput | HotmartPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartPurchases.
     */
    cursor?: HotmartPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartPurchases.
     */
    distinct?: HotmartPurchaseScalarFieldEnum | HotmartPurchaseScalarFieldEnum[]
  }

  /**
   * HotmartPurchase findMany
   */
  export type HotmartPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPurchases to fetch.
     */
    where?: HotmartPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPurchases to fetch.
     */
    orderBy?: HotmartPurchaseOrderByWithRelationInput | HotmartPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartPurchases.
     */
    cursor?: HotmartPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPurchases.
     */
    skip?: number
    distinct?: HotmartPurchaseScalarFieldEnum | HotmartPurchaseScalarFieldEnum[]
  }

  /**
   * HotmartPurchase create
   */
  export type HotmartPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartPurchase.
     */
    data: XOR<HotmartPurchaseCreateInput, HotmartPurchaseUncheckedCreateInput>
  }

  /**
   * HotmartPurchase createMany
   */
  export type HotmartPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartPurchases.
     */
    data: HotmartPurchaseCreateManyInput | HotmartPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartPurchase createManyAndReturn
   */
  export type HotmartPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartPurchases.
     */
    data: HotmartPurchaseCreateManyInput | HotmartPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartPurchase update
   */
  export type HotmartPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartPurchase.
     */
    data: XOR<HotmartPurchaseUpdateInput, HotmartPurchaseUncheckedUpdateInput>
    /**
     * Choose, which HotmartPurchase to update.
     */
    where: HotmartPurchaseWhereUniqueInput
  }

  /**
   * HotmartPurchase updateMany
   */
  export type HotmartPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartPurchases.
     */
    data: XOR<HotmartPurchaseUpdateManyMutationInput, HotmartPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which HotmartPurchases to update
     */
    where?: HotmartPurchaseWhereInput
  }

  /**
   * HotmartPurchase upsert
   */
  export type HotmartPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartPurchase to update in case it exists.
     */
    where: HotmartPurchaseWhereUniqueInput
    /**
     * In case the HotmartPurchase found by the `where` argument doesn't exist, create a new HotmartPurchase with this data.
     */
    create: XOR<HotmartPurchaseCreateInput, HotmartPurchaseUncheckedCreateInput>
    /**
     * In case the HotmartPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartPurchaseUpdateInput, HotmartPurchaseUncheckedUpdateInput>
  }

  /**
   * HotmartPurchase delete
   */
  export type HotmartPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    /**
     * Filter which HotmartPurchase to delete.
     */
    where: HotmartPurchaseWhereUniqueInput
  }

  /**
   * HotmartPurchase deleteMany
   */
  export type HotmartPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartPurchases to delete
     */
    where?: HotmartPurchaseWhereInput
  }

  /**
   * HotmartPurchase.hotmartPaymentInfos
   */
  export type HotmartPurchase$hotmartPaymentInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    where?: HotmartPaymentInfosWhereInput
    orderBy?: HotmartPaymentInfosOrderByWithRelationInput | HotmartPaymentInfosOrderByWithRelationInput[]
    cursor?: HotmartPaymentInfosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartPaymentInfosScalarFieldEnum | HotmartPaymentInfosScalarFieldEnum[]
  }

  /**
   * HotmartPurchase.hotmartCommissions
   */
  export type HotmartPurchase$hotmartCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartCommissions
     */
    select?: HotmartCommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartCommissionsInclude<ExtArgs> | null
    where?: HotmartCommissionsWhereInput
    orderBy?: HotmartCommissionsOrderByWithRelationInput | HotmartCommissionsOrderByWithRelationInput[]
    cursor?: HotmartCommissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartCommissionsScalarFieldEnum | HotmartCommissionsScalarFieldEnum[]
  }

  /**
   * HotmartPurchase.HotmartOrderNote
   */
  export type HotmartPurchase$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    cursor?: HotmartOrderNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartPurchase without action
   */
  export type HotmartPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model HotmartPaymentInfos
   */

  export type AggregateHotmartPaymentInfos = {
    _count: HotmartPaymentInfosCountAggregateOutputType | null
    _avg: HotmartPaymentInfosAvgAggregateOutputType | null
    _sum: HotmartPaymentInfosSumAggregateOutputType | null
    _min: HotmartPaymentInfosMinAggregateOutputType | null
    _max: HotmartPaymentInfosMaxAggregateOutputType | null
  }

  export type HotmartPaymentInfosAvgAggregateOutputType = {
    id: number | null
    installmentNumbers: number | null
    hotmartPurchaseId: number | null
  }

  export type HotmartPaymentInfosSumAggregateOutputType = {
    id: number | null
    installmentNumbers: number | null
    hotmartPurchaseId: number | null
  }

  export type HotmartPaymentInfosMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    barcode: string | null
    billetUrl: string | null
    pixCode: string | null
    pixQRCode: string | null
    pixExpirationDate: Date | null
    type: string | null
    refusalReason: string | null
    installmentNumbers: number | null
    hotmartPurchaseId: number | null
  }

  export type HotmartPaymentInfosMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    barcode: string | null
    billetUrl: string | null
    pixCode: string | null
    pixQRCode: string | null
    pixExpirationDate: Date | null
    type: string | null
    refusalReason: string | null
    installmentNumbers: number | null
    hotmartPurchaseId: number | null
  }

  export type HotmartPaymentInfosCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    barcode: number
    billetUrl: number
    pixCode: number
    pixQRCode: number
    pixExpirationDate: number
    type: number
    refusalReason: number
    installmentNumbers: number
    hotmartPurchaseId: number
    _all: number
  }


  export type HotmartPaymentInfosAvgAggregateInputType = {
    id?: true
    installmentNumbers?: true
    hotmartPurchaseId?: true
  }

  export type HotmartPaymentInfosSumAggregateInputType = {
    id?: true
    installmentNumbers?: true
    hotmartPurchaseId?: true
  }

  export type HotmartPaymentInfosMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    barcode?: true
    billetUrl?: true
    pixCode?: true
    pixQRCode?: true
    pixExpirationDate?: true
    type?: true
    refusalReason?: true
    installmentNumbers?: true
    hotmartPurchaseId?: true
  }

  export type HotmartPaymentInfosMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    barcode?: true
    billetUrl?: true
    pixCode?: true
    pixQRCode?: true
    pixExpirationDate?: true
    type?: true
    refusalReason?: true
    installmentNumbers?: true
    hotmartPurchaseId?: true
  }

  export type HotmartPaymentInfosCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    barcode?: true
    billetUrl?: true
    pixCode?: true
    pixQRCode?: true
    pixExpirationDate?: true
    type?: true
    refusalReason?: true
    installmentNumbers?: true
    hotmartPurchaseId?: true
    _all?: true
  }

  export type HotmartPaymentInfosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartPaymentInfos to aggregate.
     */
    where?: HotmartPaymentInfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPaymentInfos to fetch.
     */
    orderBy?: HotmartPaymentInfosOrderByWithRelationInput | HotmartPaymentInfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartPaymentInfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPaymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPaymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartPaymentInfos
    **/
    _count?: true | HotmartPaymentInfosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartPaymentInfosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartPaymentInfosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartPaymentInfosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartPaymentInfosMaxAggregateInputType
  }

  export type GetHotmartPaymentInfosAggregateType<T extends HotmartPaymentInfosAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartPaymentInfos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartPaymentInfos[P]>
      : GetScalarType<T[P], AggregateHotmartPaymentInfos[P]>
  }




  export type HotmartPaymentInfosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartPaymentInfosWhereInput
    orderBy?: HotmartPaymentInfosOrderByWithAggregationInput | HotmartPaymentInfosOrderByWithAggregationInput[]
    by: HotmartPaymentInfosScalarFieldEnum[] | HotmartPaymentInfosScalarFieldEnum
    having?: HotmartPaymentInfosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartPaymentInfosCountAggregateInputType | true
    _avg?: HotmartPaymentInfosAvgAggregateInputType
    _sum?: HotmartPaymentInfosSumAggregateInputType
    _min?: HotmartPaymentInfosMinAggregateInputType
    _max?: HotmartPaymentInfosMaxAggregateInputType
  }

  export type HotmartPaymentInfosGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    barcode: string | null
    billetUrl: string | null
    pixCode: string | null
    pixQRCode: string | null
    pixExpirationDate: Date | null
    type: string | null
    refusalReason: string | null
    installmentNumbers: number | null
    hotmartPurchaseId: number | null
    _count: HotmartPaymentInfosCountAggregateOutputType | null
    _avg: HotmartPaymentInfosAvgAggregateOutputType | null
    _sum: HotmartPaymentInfosSumAggregateOutputType | null
    _min: HotmartPaymentInfosMinAggregateOutputType | null
    _max: HotmartPaymentInfosMaxAggregateOutputType | null
  }

  type GetHotmartPaymentInfosGroupByPayload<T extends HotmartPaymentInfosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartPaymentInfosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartPaymentInfosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartPaymentInfosGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartPaymentInfosGroupByOutputType[P]>
        }
      >
    >


  export type HotmartPaymentInfosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    barcode?: boolean
    billetUrl?: boolean
    pixCode?: boolean
    pixQRCode?: boolean
    pixExpirationDate?: boolean
    type?: boolean
    refusalReason?: boolean
    installmentNumbers?: boolean
    hotmartPurchaseId?: boolean
    HotmartPurchase?: boolean | HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartPaymentInfos"]>

  export type HotmartPaymentInfosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    barcode?: boolean
    billetUrl?: boolean
    pixCode?: boolean
    pixQRCode?: boolean
    pixExpirationDate?: boolean
    type?: boolean
    refusalReason?: boolean
    installmentNumbers?: boolean
    hotmartPurchaseId?: boolean
    HotmartPurchase?: boolean | HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartPaymentInfos"]>

  export type HotmartPaymentInfosSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    barcode?: boolean
    billetUrl?: boolean
    pixCode?: boolean
    pixQRCode?: boolean
    pixExpirationDate?: boolean
    type?: boolean
    refusalReason?: boolean
    installmentNumbers?: boolean
    hotmartPurchaseId?: boolean
  }

  export type HotmartPaymentInfosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartPurchase?: boolean | HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs>
  }
  export type HotmartPaymentInfosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartPurchase?: boolean | HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs>
  }

  export type $HotmartPaymentInfosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartPaymentInfos"
    objects: {
      HotmartPurchase: Prisma.$HotmartPurchasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      barcode: string | null
      billetUrl: string | null
      pixCode: string | null
      pixQRCode: string | null
      pixExpirationDate: Date | null
      type: string | null
      refusalReason: string | null
      installmentNumbers: number | null
      hotmartPurchaseId: number | null
    }, ExtArgs["result"]["hotmartPaymentInfos"]>
    composites: {}
  }

  type HotmartPaymentInfosGetPayload<S extends boolean | null | undefined | HotmartPaymentInfosDefaultArgs> = $Result.GetResult<Prisma.$HotmartPaymentInfosPayload, S>

  type HotmartPaymentInfosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartPaymentInfosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartPaymentInfosCountAggregateInputType | true
    }

  export interface HotmartPaymentInfosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartPaymentInfos'], meta: { name: 'HotmartPaymentInfos' } }
    /**
     * Find zero or one HotmartPaymentInfos that matches the filter.
     * @param {HotmartPaymentInfosFindUniqueArgs} args - Arguments to find a HotmartPaymentInfos
     * @example
     * // Get one HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartPaymentInfosFindUniqueArgs>(args: SelectSubset<T, HotmartPaymentInfosFindUniqueArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartPaymentInfos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartPaymentInfosFindUniqueOrThrowArgs} args - Arguments to find a HotmartPaymentInfos
     * @example
     * // Get one HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartPaymentInfosFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartPaymentInfosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartPaymentInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosFindFirstArgs} args - Arguments to find a HotmartPaymentInfos
     * @example
     * // Get one HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartPaymentInfosFindFirstArgs>(args?: SelectSubset<T, HotmartPaymentInfosFindFirstArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartPaymentInfos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosFindFirstOrThrowArgs} args - Arguments to find a HotmartPaymentInfos
     * @example
     * // Get one HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartPaymentInfosFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartPaymentInfosFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartPaymentInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findMany()
     * 
     * // Get first 10 HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartPaymentInfosWithIdOnly = await prisma.hotmartPaymentInfos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartPaymentInfosFindManyArgs>(args?: SelectSubset<T, HotmartPaymentInfosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartPaymentInfos.
     * @param {HotmartPaymentInfosCreateArgs} args - Arguments to create a HotmartPaymentInfos.
     * @example
     * // Create one HotmartPaymentInfos
     * const HotmartPaymentInfos = await prisma.hotmartPaymentInfos.create({
     *   data: {
     *     // ... data to create a HotmartPaymentInfos
     *   }
     * })
     * 
     */
    create<T extends HotmartPaymentInfosCreateArgs>(args: SelectSubset<T, HotmartPaymentInfosCreateArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartPaymentInfos.
     * @param {HotmartPaymentInfosCreateManyArgs} args - Arguments to create many HotmartPaymentInfos.
     * @example
     * // Create many HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartPaymentInfosCreateManyArgs>(args?: SelectSubset<T, HotmartPaymentInfosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartPaymentInfos and returns the data saved in the database.
     * @param {HotmartPaymentInfosCreateManyAndReturnArgs} args - Arguments to create many HotmartPaymentInfos.
     * @example
     * // Create many HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartPaymentInfos and only return the `id`
     * const hotmartPaymentInfosWithIdOnly = await prisma.hotmartPaymentInfos.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartPaymentInfosCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartPaymentInfosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartPaymentInfos.
     * @param {HotmartPaymentInfosDeleteArgs} args - Arguments to delete one HotmartPaymentInfos.
     * @example
     * // Delete one HotmartPaymentInfos
     * const HotmartPaymentInfos = await prisma.hotmartPaymentInfos.delete({
     *   where: {
     *     // ... filter to delete one HotmartPaymentInfos
     *   }
     * })
     * 
     */
    delete<T extends HotmartPaymentInfosDeleteArgs>(args: SelectSubset<T, HotmartPaymentInfosDeleteArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartPaymentInfos.
     * @param {HotmartPaymentInfosUpdateArgs} args - Arguments to update one HotmartPaymentInfos.
     * @example
     * // Update one HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartPaymentInfosUpdateArgs>(args: SelectSubset<T, HotmartPaymentInfosUpdateArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartPaymentInfos.
     * @param {HotmartPaymentInfosDeleteManyArgs} args - Arguments to filter HotmartPaymentInfos to delete.
     * @example
     * // Delete a few HotmartPaymentInfos
     * const { count } = await prisma.hotmartPaymentInfos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartPaymentInfosDeleteManyArgs>(args?: SelectSubset<T, HotmartPaymentInfosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartPaymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartPaymentInfosUpdateManyArgs>(args: SelectSubset<T, HotmartPaymentInfosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartPaymentInfos.
     * @param {HotmartPaymentInfosUpsertArgs} args - Arguments to update or create a HotmartPaymentInfos.
     * @example
     * // Update or create a HotmartPaymentInfos
     * const hotmartPaymentInfos = await prisma.hotmartPaymentInfos.upsert({
     *   create: {
     *     // ... data to create a HotmartPaymentInfos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartPaymentInfos we want to update
     *   }
     * })
     */
    upsert<T extends HotmartPaymentInfosUpsertArgs>(args: SelectSubset<T, HotmartPaymentInfosUpsertArgs<ExtArgs>>): Prisma__HotmartPaymentInfosClient<$Result.GetResult<Prisma.$HotmartPaymentInfosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartPaymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosCountArgs} args - Arguments to filter HotmartPaymentInfos to count.
     * @example
     * // Count the number of HotmartPaymentInfos
     * const count = await prisma.hotmartPaymentInfos.count({
     *   where: {
     *     // ... the filter for the HotmartPaymentInfos we want to count
     *   }
     * })
    **/
    count<T extends HotmartPaymentInfosCountArgs>(
      args?: Subset<T, HotmartPaymentInfosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartPaymentInfosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartPaymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartPaymentInfosAggregateArgs>(args: Subset<T, HotmartPaymentInfosAggregateArgs>): Prisma.PrismaPromise<GetHotmartPaymentInfosAggregateType<T>>

    /**
     * Group by HotmartPaymentInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartPaymentInfosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartPaymentInfosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartPaymentInfosGroupByArgs['orderBy'] }
        : { orderBy?: HotmartPaymentInfosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartPaymentInfosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartPaymentInfosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartPaymentInfos model
   */
  readonly fields: HotmartPaymentInfosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartPaymentInfos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartPaymentInfosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartPurchase<T extends HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs> = {}>(args?: Subset<T, HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs>>): Prisma__HotmartPurchaseClient<$Result.GetResult<Prisma.$HotmartPurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartPaymentInfos model
   */ 
  interface HotmartPaymentInfosFieldRefs {
    readonly id: FieldRef<"HotmartPaymentInfos", 'Int'>
    readonly creationDate: FieldRef<"HotmartPaymentInfos", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartPaymentInfos", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartPaymentInfos", 'DateTime'>
    readonly barcode: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly billetUrl: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly pixCode: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly pixQRCode: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly pixExpirationDate: FieldRef<"HotmartPaymentInfos", 'DateTime'>
    readonly type: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly refusalReason: FieldRef<"HotmartPaymentInfos", 'String'>
    readonly installmentNumbers: FieldRef<"HotmartPaymentInfos", 'Int'>
    readonly hotmartPurchaseId: FieldRef<"HotmartPaymentInfos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotmartPaymentInfos findUnique
   */
  export type HotmartPaymentInfosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPaymentInfos to fetch.
     */
    where: HotmartPaymentInfosWhereUniqueInput
  }

  /**
   * HotmartPaymentInfos findUniqueOrThrow
   */
  export type HotmartPaymentInfosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPaymentInfos to fetch.
     */
    where: HotmartPaymentInfosWhereUniqueInput
  }

  /**
   * HotmartPaymentInfos findFirst
   */
  export type HotmartPaymentInfosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPaymentInfos to fetch.
     */
    where?: HotmartPaymentInfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPaymentInfos to fetch.
     */
    orderBy?: HotmartPaymentInfosOrderByWithRelationInput | HotmartPaymentInfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartPaymentInfos.
     */
    cursor?: HotmartPaymentInfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPaymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPaymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartPaymentInfos.
     */
    distinct?: HotmartPaymentInfosScalarFieldEnum | HotmartPaymentInfosScalarFieldEnum[]
  }

  /**
   * HotmartPaymentInfos findFirstOrThrow
   */
  export type HotmartPaymentInfosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPaymentInfos to fetch.
     */
    where?: HotmartPaymentInfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPaymentInfos to fetch.
     */
    orderBy?: HotmartPaymentInfosOrderByWithRelationInput | HotmartPaymentInfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartPaymentInfos.
     */
    cursor?: HotmartPaymentInfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPaymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPaymentInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartPaymentInfos.
     */
    distinct?: HotmartPaymentInfosScalarFieldEnum | HotmartPaymentInfosScalarFieldEnum[]
  }

  /**
   * HotmartPaymentInfos findMany
   */
  export type HotmartPaymentInfosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter, which HotmartPaymentInfos to fetch.
     */
    where?: HotmartPaymentInfosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartPaymentInfos to fetch.
     */
    orderBy?: HotmartPaymentInfosOrderByWithRelationInput | HotmartPaymentInfosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartPaymentInfos.
     */
    cursor?: HotmartPaymentInfosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartPaymentInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartPaymentInfos.
     */
    skip?: number
    distinct?: HotmartPaymentInfosScalarFieldEnum | HotmartPaymentInfosScalarFieldEnum[]
  }

  /**
   * HotmartPaymentInfos create
   */
  export type HotmartPaymentInfosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartPaymentInfos.
     */
    data: XOR<HotmartPaymentInfosCreateInput, HotmartPaymentInfosUncheckedCreateInput>
  }

  /**
   * HotmartPaymentInfos createMany
   */
  export type HotmartPaymentInfosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartPaymentInfos.
     */
    data: HotmartPaymentInfosCreateManyInput | HotmartPaymentInfosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartPaymentInfos createManyAndReturn
   */
  export type HotmartPaymentInfosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartPaymentInfos.
     */
    data: HotmartPaymentInfosCreateManyInput | HotmartPaymentInfosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotmartPaymentInfos update
   */
  export type HotmartPaymentInfosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartPaymentInfos.
     */
    data: XOR<HotmartPaymentInfosUpdateInput, HotmartPaymentInfosUncheckedUpdateInput>
    /**
     * Choose, which HotmartPaymentInfos to update.
     */
    where: HotmartPaymentInfosWhereUniqueInput
  }

  /**
   * HotmartPaymentInfos updateMany
   */
  export type HotmartPaymentInfosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartPaymentInfos.
     */
    data: XOR<HotmartPaymentInfosUpdateManyMutationInput, HotmartPaymentInfosUncheckedUpdateManyInput>
    /**
     * Filter which HotmartPaymentInfos to update
     */
    where?: HotmartPaymentInfosWhereInput
  }

  /**
   * HotmartPaymentInfos upsert
   */
  export type HotmartPaymentInfosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartPaymentInfos to update in case it exists.
     */
    where: HotmartPaymentInfosWhereUniqueInput
    /**
     * In case the HotmartPaymentInfos found by the `where` argument doesn't exist, create a new HotmartPaymentInfos with this data.
     */
    create: XOR<HotmartPaymentInfosCreateInput, HotmartPaymentInfosUncheckedCreateInput>
    /**
     * In case the HotmartPaymentInfos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartPaymentInfosUpdateInput, HotmartPaymentInfosUncheckedUpdateInput>
  }

  /**
   * HotmartPaymentInfos delete
   */
  export type HotmartPaymentInfosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
    /**
     * Filter which HotmartPaymentInfos to delete.
     */
    where: HotmartPaymentInfosWhereUniqueInput
  }

  /**
   * HotmartPaymentInfos deleteMany
   */
  export type HotmartPaymentInfosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartPaymentInfos to delete
     */
    where?: HotmartPaymentInfosWhereInput
  }

  /**
   * HotmartPaymentInfos.HotmartPurchase
   */
  export type HotmartPaymentInfos$HotmartPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPurchase
     */
    select?: HotmartPurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPurchaseInclude<ExtArgs> | null
    where?: HotmartPurchaseWhereInput
  }

  /**
   * HotmartPaymentInfos without action
   */
  export type HotmartPaymentInfosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartPaymentInfos
     */
    select?: HotmartPaymentInfosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartPaymentInfosInclude<ExtArgs> | null
  }


  /**
   * Model HotmartSubscription
   */

  export type AggregateHotmartSubscription = {
    _count: HotmartSubscriptionCountAggregateOutputType | null
    _avg: HotmartSubscriptionAvgAggregateOutputType | null
    _sum: HotmartSubscriptionSumAggregateOutputType | null
    _min: HotmartSubscriptionMinAggregateOutputType | null
    _max: HotmartSubscriptionMaxAggregateOutputType | null
  }

  export type HotmartSubscriptionAvgAggregateOutputType = {
    id: number | null
    planId: number | null
  }

  export type HotmartSubscriptionSumAggregateOutputType = {
    id: number | null
    planId: number | null
  }

  export type HotmartSubscriptionMinAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    planId: number | null
    subscriptionName: string | null
    subscriberCode: string | null
    subscriberStatus: string | null
  }

  export type HotmartSubscriptionMaxAggregateOutputType = {
    id: number | null
    creationDate: Date | null
    updateDate: Date | null
    deletionDate: Date | null
    planId: number | null
    subscriptionName: string | null
    subscriberCode: string | null
    subscriberStatus: string | null
  }

  export type HotmartSubscriptionCountAggregateOutputType = {
    id: number
    creationDate: number
    updateDate: number
    deletionDate: number
    planId: number
    subscriptionName: number
    subscriberCode: number
    subscriberStatus: number
    _all: number
  }


  export type HotmartSubscriptionAvgAggregateInputType = {
    id?: true
    planId?: true
  }

  export type HotmartSubscriptionSumAggregateInputType = {
    id?: true
    planId?: true
  }

  export type HotmartSubscriptionMinAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    planId?: true
    subscriptionName?: true
    subscriberCode?: true
    subscriberStatus?: true
  }

  export type HotmartSubscriptionMaxAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    planId?: true
    subscriptionName?: true
    subscriberCode?: true
    subscriberStatus?: true
  }

  export type HotmartSubscriptionCountAggregateInputType = {
    id?: true
    creationDate?: true
    updateDate?: true
    deletionDate?: true
    planId?: true
    subscriptionName?: true
    subscriberCode?: true
    subscriberStatus?: true
    _all?: true
  }

  export type HotmartSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartSubscription to aggregate.
     */
    where?: HotmartSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartSubscriptions to fetch.
     */
    orderBy?: HotmartSubscriptionOrderByWithRelationInput | HotmartSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotmartSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotmartSubscriptions
    **/
    _count?: true | HotmartSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotmartSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotmartSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotmartSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotmartSubscriptionMaxAggregateInputType
  }

  export type GetHotmartSubscriptionAggregateType<T extends HotmartSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateHotmartSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotmartSubscription[P]>
      : GetScalarType<T[P], AggregateHotmartSubscription[P]>
  }




  export type HotmartSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotmartSubscriptionWhereInput
    orderBy?: HotmartSubscriptionOrderByWithAggregationInput | HotmartSubscriptionOrderByWithAggregationInput[]
    by: HotmartSubscriptionScalarFieldEnum[] | HotmartSubscriptionScalarFieldEnum
    having?: HotmartSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotmartSubscriptionCountAggregateInputType | true
    _avg?: HotmartSubscriptionAvgAggregateInputType
    _sum?: HotmartSubscriptionSumAggregateInputType
    _min?: HotmartSubscriptionMinAggregateInputType
    _max?: HotmartSubscriptionMaxAggregateInputType
  }

  export type HotmartSubscriptionGroupByOutputType = {
    id: number
    creationDate: Date
    updateDate: Date
    deletionDate: Date | null
    planId: number | null
    subscriptionName: string | null
    subscriberCode: string | null
    subscriberStatus: string | null
    _count: HotmartSubscriptionCountAggregateOutputType | null
    _avg: HotmartSubscriptionAvgAggregateOutputType | null
    _sum: HotmartSubscriptionSumAggregateOutputType | null
    _min: HotmartSubscriptionMinAggregateOutputType | null
    _max: HotmartSubscriptionMaxAggregateOutputType | null
  }

  type GetHotmartSubscriptionGroupByPayload<T extends HotmartSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotmartSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotmartSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotmartSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], HotmartSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type HotmartSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    planId?: boolean
    subscriptionName?: boolean
    subscriberCode?: boolean
    subscriberStatus?: boolean
    HotmartOrderNote?: boolean | HotmartSubscription$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotmartSubscription"]>

  export type HotmartSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    planId?: boolean
    subscriptionName?: boolean
    subscriberCode?: boolean
    subscriberStatus?: boolean
  }, ExtArgs["result"]["hotmartSubscription"]>

  export type HotmartSubscriptionSelectScalar = {
    id?: boolean
    creationDate?: boolean
    updateDate?: boolean
    deletionDate?: boolean
    planId?: boolean
    subscriptionName?: boolean
    subscriberCode?: boolean
    subscriberStatus?: boolean
  }

  export type HotmartSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    HotmartOrderNote?: boolean | HotmartSubscription$HotmartOrderNoteArgs<ExtArgs>
    _count?: boolean | HotmartSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotmartSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotmartSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotmartSubscription"
    objects: {
      HotmartOrderNote: Prisma.$HotmartOrderNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creationDate: Date
      updateDate: Date
      deletionDate: Date | null
      planId: number | null
      subscriptionName: string | null
      subscriberCode: string | null
      subscriberStatus: string | null
    }, ExtArgs["result"]["hotmartSubscription"]>
    composites: {}
  }

  type HotmartSubscriptionGetPayload<S extends boolean | null | undefined | HotmartSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$HotmartSubscriptionPayload, S>

  type HotmartSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotmartSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotmartSubscriptionCountAggregateInputType | true
    }

  export interface HotmartSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotmartSubscription'], meta: { name: 'HotmartSubscription' } }
    /**
     * Find zero or one HotmartSubscription that matches the filter.
     * @param {HotmartSubscriptionFindUniqueArgs} args - Arguments to find a HotmartSubscription
     * @example
     * // Get one HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotmartSubscriptionFindUniqueArgs>(args: SelectSubset<T, HotmartSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotmartSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotmartSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a HotmartSubscription
     * @example
     * // Get one HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotmartSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, HotmartSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotmartSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionFindFirstArgs} args - Arguments to find a HotmartSubscription
     * @example
     * // Get one HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotmartSubscriptionFindFirstArgs>(args?: SelectSubset<T, HotmartSubscriptionFindFirstArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotmartSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionFindFirstOrThrowArgs} args - Arguments to find a HotmartSubscription
     * @example
     * // Get one HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotmartSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, HotmartSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotmartSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotmartSubscriptions
     * const hotmartSubscriptions = await prisma.hotmartSubscription.findMany()
     * 
     * // Get first 10 HotmartSubscriptions
     * const hotmartSubscriptions = await prisma.hotmartSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotmartSubscriptionWithIdOnly = await prisma.hotmartSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotmartSubscriptionFindManyArgs>(args?: SelectSubset<T, HotmartSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotmartSubscription.
     * @param {HotmartSubscriptionCreateArgs} args - Arguments to create a HotmartSubscription.
     * @example
     * // Create one HotmartSubscription
     * const HotmartSubscription = await prisma.hotmartSubscription.create({
     *   data: {
     *     // ... data to create a HotmartSubscription
     *   }
     * })
     * 
     */
    create<T extends HotmartSubscriptionCreateArgs>(args: SelectSubset<T, HotmartSubscriptionCreateArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotmartSubscriptions.
     * @param {HotmartSubscriptionCreateManyArgs} args - Arguments to create many HotmartSubscriptions.
     * @example
     * // Create many HotmartSubscriptions
     * const hotmartSubscription = await prisma.hotmartSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotmartSubscriptionCreateManyArgs>(args?: SelectSubset<T, HotmartSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotmartSubscriptions and returns the data saved in the database.
     * @param {HotmartSubscriptionCreateManyAndReturnArgs} args - Arguments to create many HotmartSubscriptions.
     * @example
     * // Create many HotmartSubscriptions
     * const hotmartSubscription = await prisma.hotmartSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotmartSubscriptions and only return the `id`
     * const hotmartSubscriptionWithIdOnly = await prisma.hotmartSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotmartSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, HotmartSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotmartSubscription.
     * @param {HotmartSubscriptionDeleteArgs} args - Arguments to delete one HotmartSubscription.
     * @example
     * // Delete one HotmartSubscription
     * const HotmartSubscription = await prisma.hotmartSubscription.delete({
     *   where: {
     *     // ... filter to delete one HotmartSubscription
     *   }
     * })
     * 
     */
    delete<T extends HotmartSubscriptionDeleteArgs>(args: SelectSubset<T, HotmartSubscriptionDeleteArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotmartSubscription.
     * @param {HotmartSubscriptionUpdateArgs} args - Arguments to update one HotmartSubscription.
     * @example
     * // Update one HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotmartSubscriptionUpdateArgs>(args: SelectSubset<T, HotmartSubscriptionUpdateArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotmartSubscriptions.
     * @param {HotmartSubscriptionDeleteManyArgs} args - Arguments to filter HotmartSubscriptions to delete.
     * @example
     * // Delete a few HotmartSubscriptions
     * const { count } = await prisma.hotmartSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotmartSubscriptionDeleteManyArgs>(args?: SelectSubset<T, HotmartSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotmartSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotmartSubscriptions
     * const hotmartSubscription = await prisma.hotmartSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotmartSubscriptionUpdateManyArgs>(args: SelectSubset<T, HotmartSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotmartSubscription.
     * @param {HotmartSubscriptionUpsertArgs} args - Arguments to update or create a HotmartSubscription.
     * @example
     * // Update or create a HotmartSubscription
     * const hotmartSubscription = await prisma.hotmartSubscription.upsert({
     *   create: {
     *     // ... data to create a HotmartSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotmartSubscription we want to update
     *   }
     * })
     */
    upsert<T extends HotmartSubscriptionUpsertArgs>(args: SelectSubset<T, HotmartSubscriptionUpsertArgs<ExtArgs>>): Prisma__HotmartSubscriptionClient<$Result.GetResult<Prisma.$HotmartSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotmartSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionCountArgs} args - Arguments to filter HotmartSubscriptions to count.
     * @example
     * // Count the number of HotmartSubscriptions
     * const count = await prisma.hotmartSubscription.count({
     *   where: {
     *     // ... the filter for the HotmartSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends HotmartSubscriptionCountArgs>(
      args?: Subset<T, HotmartSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotmartSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotmartSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotmartSubscriptionAggregateArgs>(args: Subset<T, HotmartSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetHotmartSubscriptionAggregateType<T>>

    /**
     * Group by HotmartSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotmartSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotmartSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotmartSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: HotmartSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotmartSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotmartSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotmartSubscription model
   */
  readonly fields: HotmartSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotmartSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotmartSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    HotmartOrderNote<T extends HotmartSubscription$HotmartOrderNoteArgs<ExtArgs> = {}>(args?: Subset<T, HotmartSubscription$HotmartOrderNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotmartOrderNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotmartSubscription model
   */ 
  interface HotmartSubscriptionFieldRefs {
    readonly id: FieldRef<"HotmartSubscription", 'Int'>
    readonly creationDate: FieldRef<"HotmartSubscription", 'DateTime'>
    readonly updateDate: FieldRef<"HotmartSubscription", 'DateTime'>
    readonly deletionDate: FieldRef<"HotmartSubscription", 'DateTime'>
    readonly planId: FieldRef<"HotmartSubscription", 'Int'>
    readonly subscriptionName: FieldRef<"HotmartSubscription", 'String'>
    readonly subscriberCode: FieldRef<"HotmartSubscription", 'String'>
    readonly subscriberStatus: FieldRef<"HotmartSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HotmartSubscription findUnique
   */
  export type HotmartSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which HotmartSubscription to fetch.
     */
    where: HotmartSubscriptionWhereUniqueInput
  }

  /**
   * HotmartSubscription findUniqueOrThrow
   */
  export type HotmartSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which HotmartSubscription to fetch.
     */
    where: HotmartSubscriptionWhereUniqueInput
  }

  /**
   * HotmartSubscription findFirst
   */
  export type HotmartSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which HotmartSubscription to fetch.
     */
    where?: HotmartSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartSubscriptions to fetch.
     */
    orderBy?: HotmartSubscriptionOrderByWithRelationInput | HotmartSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartSubscriptions.
     */
    cursor?: HotmartSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartSubscriptions.
     */
    distinct?: HotmartSubscriptionScalarFieldEnum | HotmartSubscriptionScalarFieldEnum[]
  }

  /**
   * HotmartSubscription findFirstOrThrow
   */
  export type HotmartSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which HotmartSubscription to fetch.
     */
    where?: HotmartSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartSubscriptions to fetch.
     */
    orderBy?: HotmartSubscriptionOrderByWithRelationInput | HotmartSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotmartSubscriptions.
     */
    cursor?: HotmartSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotmartSubscriptions.
     */
    distinct?: HotmartSubscriptionScalarFieldEnum | HotmartSubscriptionScalarFieldEnum[]
  }

  /**
   * HotmartSubscription findMany
   */
  export type HotmartSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which HotmartSubscriptions to fetch.
     */
    where?: HotmartSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotmartSubscriptions to fetch.
     */
    orderBy?: HotmartSubscriptionOrderByWithRelationInput | HotmartSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotmartSubscriptions.
     */
    cursor?: HotmartSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotmartSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotmartSubscriptions.
     */
    skip?: number
    distinct?: HotmartSubscriptionScalarFieldEnum | HotmartSubscriptionScalarFieldEnum[]
  }

  /**
   * HotmartSubscription create
   */
  export type HotmartSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a HotmartSubscription.
     */
    data: XOR<HotmartSubscriptionCreateInput, HotmartSubscriptionUncheckedCreateInput>
  }

  /**
   * HotmartSubscription createMany
   */
  export type HotmartSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotmartSubscriptions.
     */
    data: HotmartSubscriptionCreateManyInput | HotmartSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartSubscription createManyAndReturn
   */
  export type HotmartSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotmartSubscriptions.
     */
    data: HotmartSubscriptionCreateManyInput | HotmartSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotmartSubscription update
   */
  export type HotmartSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a HotmartSubscription.
     */
    data: XOR<HotmartSubscriptionUpdateInput, HotmartSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which HotmartSubscription to update.
     */
    where: HotmartSubscriptionWhereUniqueInput
  }

  /**
   * HotmartSubscription updateMany
   */
  export type HotmartSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotmartSubscriptions.
     */
    data: XOR<HotmartSubscriptionUpdateManyMutationInput, HotmartSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which HotmartSubscriptions to update
     */
    where?: HotmartSubscriptionWhereInput
  }

  /**
   * HotmartSubscription upsert
   */
  export type HotmartSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the HotmartSubscription to update in case it exists.
     */
    where: HotmartSubscriptionWhereUniqueInput
    /**
     * In case the HotmartSubscription found by the `where` argument doesn't exist, create a new HotmartSubscription with this data.
     */
    create: XOR<HotmartSubscriptionCreateInput, HotmartSubscriptionUncheckedCreateInput>
    /**
     * In case the HotmartSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotmartSubscriptionUpdateInput, HotmartSubscriptionUncheckedUpdateInput>
  }

  /**
   * HotmartSubscription delete
   */
  export type HotmartSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which HotmartSubscription to delete.
     */
    where: HotmartSubscriptionWhereUniqueInput
  }

  /**
   * HotmartSubscription deleteMany
   */
  export type HotmartSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotmartSubscriptions to delete
     */
    where?: HotmartSubscriptionWhereInput
  }

  /**
   * HotmartSubscription.HotmartOrderNote
   */
  export type HotmartSubscription$HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartOrderNote
     */
    select?: HotmartOrderNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartOrderNoteInclude<ExtArgs> | null
    where?: HotmartOrderNoteWhereInput
    orderBy?: HotmartOrderNoteOrderByWithRelationInput | HotmartOrderNoteOrderByWithRelationInput[]
    cursor?: HotmartOrderNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotmartOrderNoteScalarFieldEnum | HotmartOrderNoteScalarFieldEnum[]
  }

  /**
   * HotmartSubscription without action
   */
  export type HotmartSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotmartSubscription
     */
    select?: HotmartSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotmartSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ExternalWebhookHotmartReceiverScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    requestId: 'requestId',
    eventDate: 'eventDate',
    eventName: 'eventName',
    version: 'version',
    payload: 'payload'
  };

  export type ExternalWebhookHotmartReceiverScalarFieldEnum = (typeof ExternalWebhookHotmartReceiverScalarFieldEnum)[keyof typeof ExternalWebhookHotmartReceiverScalarFieldEnum]


  export const HotmartOrderNoteScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    externalWebhookHotmartReceiverId: 'externalWebhookHotmartReceiverId',
    hotmartProductId: 'hotmartProductId',
    hotmartBuyerId: 'hotmartBuyerId',
    producerName: 'producerName',
    hotmartPurchaseId: 'hotmartPurchaseId',
    hotmartSubscriptionId: 'hotmartSubscriptionId'
  };

  export type HotmartOrderNoteScalarFieldEnum = (typeof HotmartOrderNoteScalarFieldEnum)[keyof typeof HotmartOrderNoteScalarFieldEnum]


  export const HotmartProductScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    lastOrderDate: 'lastOrderDate',
    productUcode: 'productUcode',
    productName: 'productName',
    productHasCoProduction: 'productHasCoProduction'
  };

  export type HotmartProductScalarFieldEnum = (typeof HotmartProductScalarFieldEnum)[keyof typeof HotmartProductScalarFieldEnum]


  export const HotmartAffiliatesScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    lastOrderDate: 'lastOrderDate',
    affiliateCode: 'affiliateCode',
    affiliateName: 'affiliateName',
    hotmartOrderNoteId: 'hotmartOrderNoteId'
  };

  export type HotmartAffiliatesScalarFieldEnum = (typeof HotmartAffiliatesScalarFieldEnum)[keyof typeof HotmartAffiliatesScalarFieldEnum]


  export const HotmartBuyerScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    buyerEmail: 'buyerEmail',
    buyerDocument: 'buyerDocument',
    buyerName: 'buyerName',
    buyerCheckoutPhone: 'buyerCheckoutPhone',
    buyerAddressCountryIso: 'buyerAddressCountryIso',
    buyerAddressCountry: 'buyerAddressCountry',
    buyerAddressZipCode: 'buyerAddressZipCode',
    buyerAddressState: 'buyerAddressState',
    buyerAddressCity: 'buyerAddressCity',
    buyerAddressNeighborhood: 'buyerAddressNeighborhood',
    buyerAddressStreet: 'buyerAddressStreet',
    buyerAddressComplement: 'buyerAddressComplement',
    buyerAddressNumber: 'buyerAddressNumber',
    lastOrderDate: 'lastOrderDate'
  };

  export type HotmartBuyerScalarFieldEnum = (typeof HotmartBuyerScalarFieldEnum)[keyof typeof HotmartBuyerScalarFieldEnum]


  export const HotmartCommissionsScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    sourceName: 'sourceName',
    value: 'value',
    currencyValue: 'currencyValue',
    convertedToCurrency: 'convertedToCurrency',
    convertedvalue: 'convertedvalue',
    currencyConvertionRate: 'currencyConvertionRate',
    hotmartPurchaseId: 'hotmartPurchaseId'
  };

  export type HotmartCommissionsScalarFieldEnum = (typeof HotmartCommissionsScalarFieldEnum)[keyof typeof HotmartCommissionsScalarFieldEnum]


  export const HotmartPurchaseScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    orderDate: 'orderDate',
    approvedDate: 'approvedDate',
    transactionId: 'transactionId',
    status: 'status',
    fullPriceValue: 'fullPriceValue',
    fullPriceCurrency: 'fullPriceCurrency',
    originalPriceValue: 'originalPriceValue',
    originalPriceCurrency: 'originalPriceCurrency',
    priceValue: 'priceValue',
    priceCurrency: 'priceCurrency',
    offerCode: 'offerCode',
    recurrencyNumber: 'recurrencyNumber',
    subscriptionAnticipationPurchase: 'subscriptionAnticipationPurchase',
    checkoutCountryName: 'checkoutCountryName',
    checkoutCountryISO: 'checkoutCountryISO',
    utmCode: 'utmCode',
    isOrderBump: 'isOrderBump',
    originalTransactionId: 'originalTransactionId',
    nextChargeDate: 'nextChargeDate'
  };

  export type HotmartPurchaseScalarFieldEnum = (typeof HotmartPurchaseScalarFieldEnum)[keyof typeof HotmartPurchaseScalarFieldEnum]


  export const HotmartPaymentInfosScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    barcode: 'barcode',
    billetUrl: 'billetUrl',
    pixCode: 'pixCode',
    pixQRCode: 'pixQRCode',
    pixExpirationDate: 'pixExpirationDate',
    type: 'type',
    refusalReason: 'refusalReason',
    installmentNumbers: 'installmentNumbers',
    hotmartPurchaseId: 'hotmartPurchaseId'
  };

  export type HotmartPaymentInfosScalarFieldEnum = (typeof HotmartPaymentInfosScalarFieldEnum)[keyof typeof HotmartPaymentInfosScalarFieldEnum]


  export const HotmartSubscriptionScalarFieldEnum: {
    id: 'id',
    creationDate: 'creationDate',
    updateDate: 'updateDate',
    deletionDate: 'deletionDate',
    planId: 'planId',
    subscriptionName: 'subscriptionName',
    subscriberCode: 'subscriberCode',
    subscriberStatus: 'subscriberStatus'
  };

  export type HotmartSubscriptionScalarFieldEnum = (typeof HotmartSubscriptionScalarFieldEnum)[keyof typeof HotmartSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ExternalWebhookHotmartReceiverWhereInput = {
    AND?: ExternalWebhookHotmartReceiverWhereInput | ExternalWebhookHotmartReceiverWhereInput[]
    OR?: ExternalWebhookHotmartReceiverWhereInput[]
    NOT?: ExternalWebhookHotmartReceiverWhereInput | ExternalWebhookHotmartReceiverWhereInput[]
    id?: IntFilter<"ExternalWebhookHotmartReceiver"> | number
    creationDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    updateDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    deletionDate?: DateTimeNullableFilter<"ExternalWebhookHotmartReceiver"> | Date | string | null
    requestId?: StringFilter<"ExternalWebhookHotmartReceiver"> | string
    eventDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    eventName?: StringFilter<"ExternalWebhookHotmartReceiver"> | string
    version?: StringFilter<"ExternalWebhookHotmartReceiver"> | string
    payload?: JsonFilter<"ExternalWebhookHotmartReceiver">
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }

  export type ExternalWebhookHotmartReceiverOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    requestId?: SortOrder
    eventDate?: SortOrder
    eventName?: SortOrder
    version?: SortOrder
    payload?: SortOrder
    HotmartOrderNote?: HotmartOrderNoteOrderByRelationAggregateInput
  }

  export type ExternalWebhookHotmartReceiverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    requestId?: string
    AND?: ExternalWebhookHotmartReceiverWhereInput | ExternalWebhookHotmartReceiverWhereInput[]
    OR?: ExternalWebhookHotmartReceiverWhereInput[]
    NOT?: ExternalWebhookHotmartReceiverWhereInput | ExternalWebhookHotmartReceiverWhereInput[]
    creationDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    updateDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    deletionDate?: DateTimeNullableFilter<"ExternalWebhookHotmartReceiver"> | Date | string | null
    eventDate?: DateTimeFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    eventName?: StringFilter<"ExternalWebhookHotmartReceiver"> | string
    version?: StringFilter<"ExternalWebhookHotmartReceiver"> | string
    payload?: JsonFilter<"ExternalWebhookHotmartReceiver">
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }, "id" | "requestId">

  export type ExternalWebhookHotmartReceiverOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    requestId?: SortOrder
    eventDate?: SortOrder
    eventName?: SortOrder
    version?: SortOrder
    payload?: SortOrder
    _count?: ExternalWebhookHotmartReceiverCountOrderByAggregateInput
    _avg?: ExternalWebhookHotmartReceiverAvgOrderByAggregateInput
    _max?: ExternalWebhookHotmartReceiverMaxOrderByAggregateInput
    _min?: ExternalWebhookHotmartReceiverMinOrderByAggregateInput
    _sum?: ExternalWebhookHotmartReceiverSumOrderByAggregateInput
  }

  export type ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput = {
    AND?: ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput | ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput[]
    OR?: ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput[]
    NOT?: ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput | ExternalWebhookHotmartReceiverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | number
    creationDate?: DateTimeWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | Date | string | null
    requestId?: StringWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | string
    eventDate?: DateTimeWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | Date | string
    eventName?: StringWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | string
    version?: StringWithAggregatesFilter<"ExternalWebhookHotmartReceiver"> | string
    payload?: JsonWithAggregatesFilter<"ExternalWebhookHotmartReceiver">
  }

  export type HotmartOrderNoteWhereInput = {
    AND?: HotmartOrderNoteWhereInput | HotmartOrderNoteWhereInput[]
    OR?: HotmartOrderNoteWhereInput[]
    NOT?: HotmartOrderNoteWhereInput | HotmartOrderNoteWhereInput[]
    id?: IntFilter<"HotmartOrderNote"> | number
    creationDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    updateDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartOrderNote"> | Date | string | null
    externalWebhookHotmartReceiverId?: IntFilter<"HotmartOrderNote"> | number
    hotmartProductId?: IntFilter<"HotmartOrderNote"> | number
    hotmartBuyerId?: IntFilter<"HotmartOrderNote"> | number
    producerName?: StringNullableFilter<"HotmartOrderNote"> | string | null
    hotmartPurchaseId?: IntFilter<"HotmartOrderNote"> | number
    hotmartSubscriptionId?: IntNullableFilter<"HotmartOrderNote"> | number | null
    externalWebhookHotmartReceiver?: XOR<ExternalWebhookHotmartReceiverRelationFilter, ExternalWebhookHotmartReceiverWhereInput>
    hotmartProduct?: XOR<HotmartProductRelationFilter, HotmartProductWhereInput>
    hotmartAffiliates?: HotmartAffiliatesListRelationFilter
    hotmartBuyer?: XOR<HotmartBuyerRelationFilter, HotmartBuyerWhereInput>
    hotmartPurchase?: XOR<HotmartPurchaseRelationFilter, HotmartPurchaseWhereInput>
    hotmartSubscription?: XOR<HotmartSubscriptionNullableRelationFilter, HotmartSubscriptionWhereInput> | null
  }

  export type HotmartOrderNoteOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    producerName?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrderInput | SortOrder
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverOrderByWithRelationInput
    hotmartProduct?: HotmartProductOrderByWithRelationInput
    hotmartAffiliates?: HotmartAffiliatesOrderByRelationAggregateInput
    hotmartBuyer?: HotmartBuyerOrderByWithRelationInput
    hotmartPurchase?: HotmartPurchaseOrderByWithRelationInput
    hotmartSubscription?: HotmartSubscriptionOrderByWithRelationInput
  }

  export type HotmartOrderNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotmartOrderNoteWhereInput | HotmartOrderNoteWhereInput[]
    OR?: HotmartOrderNoteWhereInput[]
    NOT?: HotmartOrderNoteWhereInput | HotmartOrderNoteWhereInput[]
    creationDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    updateDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartOrderNote"> | Date | string | null
    externalWebhookHotmartReceiverId?: IntFilter<"HotmartOrderNote"> | number
    hotmartProductId?: IntFilter<"HotmartOrderNote"> | number
    hotmartBuyerId?: IntFilter<"HotmartOrderNote"> | number
    producerName?: StringNullableFilter<"HotmartOrderNote"> | string | null
    hotmartPurchaseId?: IntFilter<"HotmartOrderNote"> | number
    hotmartSubscriptionId?: IntNullableFilter<"HotmartOrderNote"> | number | null
    externalWebhookHotmartReceiver?: XOR<ExternalWebhookHotmartReceiverRelationFilter, ExternalWebhookHotmartReceiverWhereInput>
    hotmartProduct?: XOR<HotmartProductRelationFilter, HotmartProductWhereInput>
    hotmartAffiliates?: HotmartAffiliatesListRelationFilter
    hotmartBuyer?: XOR<HotmartBuyerRelationFilter, HotmartBuyerWhereInput>
    hotmartPurchase?: XOR<HotmartPurchaseRelationFilter, HotmartPurchaseWhereInput>
    hotmartSubscription?: XOR<HotmartSubscriptionNullableRelationFilter, HotmartSubscriptionWhereInput> | null
  }, "id">

  export type HotmartOrderNoteOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    producerName?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrderInput | SortOrder
    _count?: HotmartOrderNoteCountOrderByAggregateInput
    _avg?: HotmartOrderNoteAvgOrderByAggregateInput
    _max?: HotmartOrderNoteMaxOrderByAggregateInput
    _min?: HotmartOrderNoteMinOrderByAggregateInput
    _sum?: HotmartOrderNoteSumOrderByAggregateInput
  }

  export type HotmartOrderNoteScalarWhereWithAggregatesInput = {
    AND?: HotmartOrderNoteScalarWhereWithAggregatesInput | HotmartOrderNoteScalarWhereWithAggregatesInput[]
    OR?: HotmartOrderNoteScalarWhereWithAggregatesInput[]
    NOT?: HotmartOrderNoteScalarWhereWithAggregatesInput | HotmartOrderNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartOrderNote"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartOrderNote"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartOrderNote"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartOrderNote"> | Date | string | null
    externalWebhookHotmartReceiverId?: IntWithAggregatesFilter<"HotmartOrderNote"> | number
    hotmartProductId?: IntWithAggregatesFilter<"HotmartOrderNote"> | number
    hotmartBuyerId?: IntWithAggregatesFilter<"HotmartOrderNote"> | number
    producerName?: StringNullableWithAggregatesFilter<"HotmartOrderNote"> | string | null
    hotmartPurchaseId?: IntWithAggregatesFilter<"HotmartOrderNote"> | number
    hotmartSubscriptionId?: IntNullableWithAggregatesFilter<"HotmartOrderNote"> | number | null
  }

  export type HotmartProductWhereInput = {
    AND?: HotmartProductWhereInput | HotmartProductWhereInput[]
    OR?: HotmartProductWhereInput[]
    NOT?: HotmartProductWhereInput | HotmartProductWhereInput[]
    id?: IntFilter<"HotmartProduct"> | number
    creationDate?: DateTimeFilter<"HotmartProduct"> | Date | string
    updateDate?: DateTimeFilter<"HotmartProduct"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartProduct"> | Date | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartProduct"> | Date | string | null
    productUcode?: StringFilter<"HotmartProduct"> | string
    productName?: StringFilter<"HotmartProduct"> | string
    productHasCoProduction?: BoolFilter<"HotmartProduct"> | boolean
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }

  export type HotmartProductOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    productUcode?: SortOrder
    productName?: SortOrder
    productHasCoProduction?: SortOrder
    HotmartOrderNote?: HotmartOrderNoteOrderByRelationAggregateInput
  }

  export type HotmartProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotmartProductWhereInput | HotmartProductWhereInput[]
    OR?: HotmartProductWhereInput[]
    NOT?: HotmartProductWhereInput | HotmartProductWhereInput[]
    creationDate?: DateTimeFilter<"HotmartProduct"> | Date | string
    updateDate?: DateTimeFilter<"HotmartProduct"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartProduct"> | Date | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartProduct"> | Date | string | null
    productUcode?: StringFilter<"HotmartProduct"> | string
    productName?: StringFilter<"HotmartProduct"> | string
    productHasCoProduction?: BoolFilter<"HotmartProduct"> | boolean
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }, "id">

  export type HotmartProductOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    productUcode?: SortOrder
    productName?: SortOrder
    productHasCoProduction?: SortOrder
    _count?: HotmartProductCountOrderByAggregateInput
    _avg?: HotmartProductAvgOrderByAggregateInput
    _max?: HotmartProductMaxOrderByAggregateInput
    _min?: HotmartProductMinOrderByAggregateInput
    _sum?: HotmartProductSumOrderByAggregateInput
  }

  export type HotmartProductScalarWhereWithAggregatesInput = {
    AND?: HotmartProductScalarWhereWithAggregatesInput | HotmartProductScalarWhereWithAggregatesInput[]
    OR?: HotmartProductScalarWhereWithAggregatesInput[]
    NOT?: HotmartProductScalarWhereWithAggregatesInput | HotmartProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartProduct"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartProduct"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartProduct"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartProduct"> | Date | string | null
    lastOrderDate?: DateTimeNullableWithAggregatesFilter<"HotmartProduct"> | Date | string | null
    productUcode?: StringWithAggregatesFilter<"HotmartProduct"> | string
    productName?: StringWithAggregatesFilter<"HotmartProduct"> | string
    productHasCoProduction?: BoolWithAggregatesFilter<"HotmartProduct"> | boolean
  }

  export type HotmartAffiliatesWhereInput = {
    AND?: HotmartAffiliatesWhereInput | HotmartAffiliatesWhereInput[]
    OR?: HotmartAffiliatesWhereInput[]
    NOT?: HotmartAffiliatesWhereInput | HotmartAffiliatesWhereInput[]
    id?: IntFilter<"HotmartAffiliates"> | number
    creationDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    updateDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    affiliateCode?: StringNullableFilter<"HotmartAffiliates"> | string | null
    affiliateName?: StringNullableFilter<"HotmartAffiliates"> | string | null
    hotmartOrderNoteId?: IntNullableFilter<"HotmartAffiliates"> | number | null
    HotmartOrderNote?: XOR<HotmartOrderNoteNullableRelationFilter, HotmartOrderNoteWhereInput> | null
  }

  export type HotmartAffiliatesOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    affiliateCode?: SortOrderInput | SortOrder
    affiliateName?: SortOrderInput | SortOrder
    hotmartOrderNoteId?: SortOrderInput | SortOrder
    HotmartOrderNote?: HotmartOrderNoteOrderByWithRelationInput
  }

  export type HotmartAffiliatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    affiliateCode?: string
    AND?: HotmartAffiliatesWhereInput | HotmartAffiliatesWhereInput[]
    OR?: HotmartAffiliatesWhereInput[]
    NOT?: HotmartAffiliatesWhereInput | HotmartAffiliatesWhereInput[]
    creationDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    updateDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    affiliateName?: StringNullableFilter<"HotmartAffiliates"> | string | null
    hotmartOrderNoteId?: IntNullableFilter<"HotmartAffiliates"> | number | null
    HotmartOrderNote?: XOR<HotmartOrderNoteNullableRelationFilter, HotmartOrderNoteWhereInput> | null
  }, "id" | "affiliateCode">

  export type HotmartAffiliatesOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    affiliateCode?: SortOrderInput | SortOrder
    affiliateName?: SortOrderInput | SortOrder
    hotmartOrderNoteId?: SortOrderInput | SortOrder
    _count?: HotmartAffiliatesCountOrderByAggregateInput
    _avg?: HotmartAffiliatesAvgOrderByAggregateInput
    _max?: HotmartAffiliatesMaxOrderByAggregateInput
    _min?: HotmartAffiliatesMinOrderByAggregateInput
    _sum?: HotmartAffiliatesSumOrderByAggregateInput
  }

  export type HotmartAffiliatesScalarWhereWithAggregatesInput = {
    AND?: HotmartAffiliatesScalarWhereWithAggregatesInput | HotmartAffiliatesScalarWhereWithAggregatesInput[]
    OR?: HotmartAffiliatesScalarWhereWithAggregatesInput[]
    NOT?: HotmartAffiliatesScalarWhereWithAggregatesInput | HotmartAffiliatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartAffiliates"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartAffiliates"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartAffiliates"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartAffiliates"> | Date | string | null
    lastOrderDate?: DateTimeNullableWithAggregatesFilter<"HotmartAffiliates"> | Date | string | null
    affiliateCode?: StringNullableWithAggregatesFilter<"HotmartAffiliates"> | string | null
    affiliateName?: StringNullableWithAggregatesFilter<"HotmartAffiliates"> | string | null
    hotmartOrderNoteId?: IntNullableWithAggregatesFilter<"HotmartAffiliates"> | number | null
  }

  export type HotmartBuyerWhereInput = {
    AND?: HotmartBuyerWhereInput | HotmartBuyerWhereInput[]
    OR?: HotmartBuyerWhereInput[]
    NOT?: HotmartBuyerWhereInput | HotmartBuyerWhereInput[]
    id?: IntFilter<"HotmartBuyer"> | number
    creationDate?: DateTimeFilter<"HotmartBuyer"> | Date | string
    updateDate?: DateTimeFilter<"HotmartBuyer"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartBuyer"> | Date | string | null
    buyerEmail?: StringFilter<"HotmartBuyer"> | string
    buyerDocument?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerName?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerCheckoutPhone?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCountryIso?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCountry?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressZipCode?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressState?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCity?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressNeighborhood?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressStreet?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressComplement?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressNumber?: StringNullableFilter<"HotmartBuyer"> | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartBuyer"> | Date | string | null
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }

  export type HotmartBuyerOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    buyerEmail?: SortOrder
    buyerDocument?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    buyerCheckoutPhone?: SortOrderInput | SortOrder
    buyerAddressCountryIso?: SortOrderInput | SortOrder
    buyerAddressCountry?: SortOrderInput | SortOrder
    buyerAddressZipCode?: SortOrderInput | SortOrder
    buyerAddressState?: SortOrderInput | SortOrder
    buyerAddressCity?: SortOrderInput | SortOrder
    buyerAddressNeighborhood?: SortOrderInput | SortOrder
    buyerAddressStreet?: SortOrderInput | SortOrder
    buyerAddressComplement?: SortOrderInput | SortOrder
    buyerAddressNumber?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    HotmartOrderNote?: HotmartOrderNoteOrderByRelationAggregateInput
  }

  export type HotmartBuyerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    buyerEmail?: string
    AND?: HotmartBuyerWhereInput | HotmartBuyerWhereInput[]
    OR?: HotmartBuyerWhereInput[]
    NOT?: HotmartBuyerWhereInput | HotmartBuyerWhereInput[]
    creationDate?: DateTimeFilter<"HotmartBuyer"> | Date | string
    updateDate?: DateTimeFilter<"HotmartBuyer"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartBuyer"> | Date | string | null
    buyerDocument?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerName?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerCheckoutPhone?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCountryIso?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCountry?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressZipCode?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressState?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressCity?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressNeighborhood?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressStreet?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressComplement?: StringNullableFilter<"HotmartBuyer"> | string | null
    buyerAddressNumber?: StringNullableFilter<"HotmartBuyer"> | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartBuyer"> | Date | string | null
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }, "id" | "buyerEmail">

  export type HotmartBuyerOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    buyerEmail?: SortOrder
    buyerDocument?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    buyerCheckoutPhone?: SortOrderInput | SortOrder
    buyerAddressCountryIso?: SortOrderInput | SortOrder
    buyerAddressCountry?: SortOrderInput | SortOrder
    buyerAddressZipCode?: SortOrderInput | SortOrder
    buyerAddressState?: SortOrderInput | SortOrder
    buyerAddressCity?: SortOrderInput | SortOrder
    buyerAddressNeighborhood?: SortOrderInput | SortOrder
    buyerAddressStreet?: SortOrderInput | SortOrder
    buyerAddressComplement?: SortOrderInput | SortOrder
    buyerAddressNumber?: SortOrderInput | SortOrder
    lastOrderDate?: SortOrderInput | SortOrder
    _count?: HotmartBuyerCountOrderByAggregateInput
    _avg?: HotmartBuyerAvgOrderByAggregateInput
    _max?: HotmartBuyerMaxOrderByAggregateInput
    _min?: HotmartBuyerMinOrderByAggregateInput
    _sum?: HotmartBuyerSumOrderByAggregateInput
  }

  export type HotmartBuyerScalarWhereWithAggregatesInput = {
    AND?: HotmartBuyerScalarWhereWithAggregatesInput | HotmartBuyerScalarWhereWithAggregatesInput[]
    OR?: HotmartBuyerScalarWhereWithAggregatesInput[]
    NOT?: HotmartBuyerScalarWhereWithAggregatesInput | HotmartBuyerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartBuyer"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartBuyer"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartBuyer"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartBuyer"> | Date | string | null
    buyerEmail?: StringWithAggregatesFilter<"HotmartBuyer"> | string
    buyerDocument?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerName?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerCheckoutPhone?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressCountryIso?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressCountry?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressZipCode?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressState?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressCity?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressNeighborhood?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressStreet?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressComplement?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    buyerAddressNumber?: StringNullableWithAggregatesFilter<"HotmartBuyer"> | string | null
    lastOrderDate?: DateTimeNullableWithAggregatesFilter<"HotmartBuyer"> | Date | string | null
  }

  export type HotmartCommissionsWhereInput = {
    AND?: HotmartCommissionsWhereInput | HotmartCommissionsWhereInput[]
    OR?: HotmartCommissionsWhereInput[]
    NOT?: HotmartCommissionsWhereInput | HotmartCommissionsWhereInput[]
    id?: IntFilter<"HotmartCommissions"> | number
    creationDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    updateDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartCommissions"> | Date | string | null
    sourceName?: StringNullableFilter<"HotmartCommissions"> | string | null
    value?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyValue?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedToCurrency?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedvalue?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartCommissions"> | number | null
    HotmartPurchase?: XOR<HotmartPurchaseNullableRelationFilter, HotmartPurchaseWhereInput> | null
  }

  export type HotmartCommissionsOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    sourceName?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    currencyValue?: SortOrderInput | SortOrder
    convertedToCurrency?: SortOrderInput | SortOrder
    convertedvalue?: SortOrderInput | SortOrder
    currencyConvertionRate?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrderInput | SortOrder
    HotmartPurchase?: HotmartPurchaseOrderByWithRelationInput
  }

  export type HotmartCommissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotmartCommissionsWhereInput | HotmartCommissionsWhereInput[]
    OR?: HotmartCommissionsWhereInput[]
    NOT?: HotmartCommissionsWhereInput | HotmartCommissionsWhereInput[]
    creationDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    updateDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartCommissions"> | Date | string | null
    sourceName?: StringNullableFilter<"HotmartCommissions"> | string | null
    value?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyValue?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedToCurrency?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedvalue?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartCommissions"> | number | null
    HotmartPurchase?: XOR<HotmartPurchaseNullableRelationFilter, HotmartPurchaseWhereInput> | null
  }, "id">

  export type HotmartCommissionsOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    sourceName?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    currencyValue?: SortOrderInput | SortOrder
    convertedToCurrency?: SortOrderInput | SortOrder
    convertedvalue?: SortOrderInput | SortOrder
    currencyConvertionRate?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrderInput | SortOrder
    _count?: HotmartCommissionsCountOrderByAggregateInput
    _avg?: HotmartCommissionsAvgOrderByAggregateInput
    _max?: HotmartCommissionsMaxOrderByAggregateInput
    _min?: HotmartCommissionsMinOrderByAggregateInput
    _sum?: HotmartCommissionsSumOrderByAggregateInput
  }

  export type HotmartCommissionsScalarWhereWithAggregatesInput = {
    AND?: HotmartCommissionsScalarWhereWithAggregatesInput | HotmartCommissionsScalarWhereWithAggregatesInput[]
    OR?: HotmartCommissionsScalarWhereWithAggregatesInput[]
    NOT?: HotmartCommissionsScalarWhereWithAggregatesInput | HotmartCommissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartCommissions"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartCommissions"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartCommissions"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartCommissions"> | Date | string | null
    sourceName?: StringNullableWithAggregatesFilter<"HotmartCommissions"> | string | null
    value?: DecimalNullableWithAggregatesFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyValue?: StringNullableWithAggregatesFilter<"HotmartCommissions"> | string | null
    convertedToCurrency?: StringNullableWithAggregatesFilter<"HotmartCommissions"> | string | null
    convertedvalue?: DecimalNullableWithAggregatesFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: DecimalNullableWithAggregatesFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: IntNullableWithAggregatesFilter<"HotmartCommissions"> | number | null
  }

  export type HotmartPurchaseWhereInput = {
    AND?: HotmartPurchaseWhereInput | HotmartPurchaseWhereInput[]
    OR?: HotmartPurchaseWhereInput[]
    NOT?: HotmartPurchaseWhereInput | HotmartPurchaseWhereInput[]
    id?: IntFilter<"HotmartPurchase"> | number
    creationDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    updateDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartPurchase"> | Date | string | null
    orderDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    approvedDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    transactionId?: StringFilter<"HotmartPurchase"> | string
    status?: StringFilter<"HotmartPurchase"> | string
    fullPriceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFilter<"HotmartPurchase"> | string
    originalPriceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFilter<"HotmartPurchase"> | string
    priceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFilter<"HotmartPurchase"> | string
    offerCode?: StringFilter<"HotmartPurchase"> | string
    recurrencyNumber?: IntNullableFilter<"HotmartPurchase"> | number | null
    subscriptionAnticipationPurchase?: BoolNullableFilter<"HotmartPurchase"> | boolean | null
    checkoutCountryName?: StringFilter<"HotmartPurchase"> | string
    checkoutCountryISO?: StringFilter<"HotmartPurchase"> | string
    utmCode?: StringNullableFilter<"HotmartPurchase"> | string | null
    isOrderBump?: BoolNullableFilter<"HotmartPurchase"> | boolean | null
    originalTransactionId?: StringNullableFilter<"HotmartPurchase"> | string | null
    nextChargeDate?: DateTimeNullableFilter<"HotmartPurchase"> | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosListRelationFilter
    hotmartCommissions?: HotmartCommissionsListRelationFilter
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }

  export type HotmartPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    approvedDate?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    fullPriceValue?: SortOrder
    fullPriceCurrency?: SortOrder
    originalPriceValue?: SortOrder
    originalPriceCurrency?: SortOrder
    priceValue?: SortOrder
    priceCurrency?: SortOrder
    offerCode?: SortOrder
    recurrencyNumber?: SortOrderInput | SortOrder
    subscriptionAnticipationPurchase?: SortOrderInput | SortOrder
    checkoutCountryName?: SortOrder
    checkoutCountryISO?: SortOrder
    utmCode?: SortOrderInput | SortOrder
    isOrderBump?: SortOrderInput | SortOrder
    originalTransactionId?: SortOrderInput | SortOrder
    nextChargeDate?: SortOrderInput | SortOrder
    hotmartPaymentInfos?: HotmartPaymentInfosOrderByRelationAggregateInput
    hotmartCommissions?: HotmartCommissionsOrderByRelationAggregateInput
    HotmartOrderNote?: HotmartOrderNoteOrderByRelationAggregateInput
  }

  export type HotmartPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionId?: string
    AND?: HotmartPurchaseWhereInput | HotmartPurchaseWhereInput[]
    OR?: HotmartPurchaseWhereInput[]
    NOT?: HotmartPurchaseWhereInput | HotmartPurchaseWhereInput[]
    creationDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    updateDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartPurchase"> | Date | string | null
    orderDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    approvedDate?: DateTimeFilter<"HotmartPurchase"> | Date | string
    status?: StringFilter<"HotmartPurchase"> | string
    fullPriceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFilter<"HotmartPurchase"> | string
    originalPriceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFilter<"HotmartPurchase"> | string
    priceValue?: DecimalFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFilter<"HotmartPurchase"> | string
    offerCode?: StringFilter<"HotmartPurchase"> | string
    recurrencyNumber?: IntNullableFilter<"HotmartPurchase"> | number | null
    subscriptionAnticipationPurchase?: BoolNullableFilter<"HotmartPurchase"> | boolean | null
    checkoutCountryName?: StringFilter<"HotmartPurchase"> | string
    checkoutCountryISO?: StringFilter<"HotmartPurchase"> | string
    utmCode?: StringNullableFilter<"HotmartPurchase"> | string | null
    isOrderBump?: BoolNullableFilter<"HotmartPurchase"> | boolean | null
    originalTransactionId?: StringNullableFilter<"HotmartPurchase"> | string | null
    nextChargeDate?: DateTimeNullableFilter<"HotmartPurchase"> | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosListRelationFilter
    hotmartCommissions?: HotmartCommissionsListRelationFilter
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }, "id" | "transactionId">

  export type HotmartPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    approvedDate?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    fullPriceValue?: SortOrder
    fullPriceCurrency?: SortOrder
    originalPriceValue?: SortOrder
    originalPriceCurrency?: SortOrder
    priceValue?: SortOrder
    priceCurrency?: SortOrder
    offerCode?: SortOrder
    recurrencyNumber?: SortOrderInput | SortOrder
    subscriptionAnticipationPurchase?: SortOrderInput | SortOrder
    checkoutCountryName?: SortOrder
    checkoutCountryISO?: SortOrder
    utmCode?: SortOrderInput | SortOrder
    isOrderBump?: SortOrderInput | SortOrder
    originalTransactionId?: SortOrderInput | SortOrder
    nextChargeDate?: SortOrderInput | SortOrder
    _count?: HotmartPurchaseCountOrderByAggregateInput
    _avg?: HotmartPurchaseAvgOrderByAggregateInput
    _max?: HotmartPurchaseMaxOrderByAggregateInput
    _min?: HotmartPurchaseMinOrderByAggregateInput
    _sum?: HotmartPurchaseSumOrderByAggregateInput
  }

  export type HotmartPurchaseScalarWhereWithAggregatesInput = {
    AND?: HotmartPurchaseScalarWhereWithAggregatesInput | HotmartPurchaseScalarWhereWithAggregatesInput[]
    OR?: HotmartPurchaseScalarWhereWithAggregatesInput[]
    NOT?: HotmartPurchaseScalarWhereWithAggregatesInput | HotmartPurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartPurchase"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartPurchase"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartPurchase"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartPurchase"> | Date | string | null
    orderDate?: DateTimeWithAggregatesFilter<"HotmartPurchase"> | Date | string
    approvedDate?: DateTimeWithAggregatesFilter<"HotmartPurchase"> | Date | string
    transactionId?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    status?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    fullPriceValue?: DecimalWithAggregatesFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    originalPriceValue?: DecimalWithAggregatesFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    priceValue?: DecimalWithAggregatesFilter<"HotmartPurchase"> | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    offerCode?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    recurrencyNumber?: IntNullableWithAggregatesFilter<"HotmartPurchase"> | number | null
    subscriptionAnticipationPurchase?: BoolNullableWithAggregatesFilter<"HotmartPurchase"> | boolean | null
    checkoutCountryName?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    checkoutCountryISO?: StringWithAggregatesFilter<"HotmartPurchase"> | string
    utmCode?: StringNullableWithAggregatesFilter<"HotmartPurchase"> | string | null
    isOrderBump?: BoolNullableWithAggregatesFilter<"HotmartPurchase"> | boolean | null
    originalTransactionId?: StringNullableWithAggregatesFilter<"HotmartPurchase"> | string | null
    nextChargeDate?: DateTimeNullableWithAggregatesFilter<"HotmartPurchase"> | Date | string | null
  }

  export type HotmartPaymentInfosWhereInput = {
    AND?: HotmartPaymentInfosWhereInput | HotmartPaymentInfosWhereInput[]
    OR?: HotmartPaymentInfosWhereInput[]
    NOT?: HotmartPaymentInfosWhereInput | HotmartPaymentInfosWhereInput[]
    id?: IntFilter<"HotmartPaymentInfos"> | number
    creationDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    updateDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    barcode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    billetUrl?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixQRCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixExpirationDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    type?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    refusalReason?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    installmentNumbers?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
    HotmartPurchase?: XOR<HotmartPurchaseNullableRelationFilter, HotmartPurchaseWhereInput> | null
  }

  export type HotmartPaymentInfosOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    billetUrl?: SortOrderInput | SortOrder
    pixCode?: SortOrderInput | SortOrder
    pixQRCode?: SortOrderInput | SortOrder
    pixExpirationDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    refusalReason?: SortOrderInput | SortOrder
    installmentNumbers?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrderInput | SortOrder
    HotmartPurchase?: HotmartPurchaseOrderByWithRelationInput
  }

  export type HotmartPaymentInfosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotmartPaymentInfosWhereInput | HotmartPaymentInfosWhereInput[]
    OR?: HotmartPaymentInfosWhereInput[]
    NOT?: HotmartPaymentInfosWhereInput | HotmartPaymentInfosWhereInput[]
    creationDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    updateDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    barcode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    billetUrl?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixQRCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixExpirationDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    type?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    refusalReason?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    installmentNumbers?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
    HotmartPurchase?: XOR<HotmartPurchaseNullableRelationFilter, HotmartPurchaseWhereInput> | null
  }, "id">

  export type HotmartPaymentInfosOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    billetUrl?: SortOrderInput | SortOrder
    pixCode?: SortOrderInput | SortOrder
    pixQRCode?: SortOrderInput | SortOrder
    pixExpirationDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    refusalReason?: SortOrderInput | SortOrder
    installmentNumbers?: SortOrderInput | SortOrder
    hotmartPurchaseId?: SortOrderInput | SortOrder
    _count?: HotmartPaymentInfosCountOrderByAggregateInput
    _avg?: HotmartPaymentInfosAvgOrderByAggregateInput
    _max?: HotmartPaymentInfosMaxOrderByAggregateInput
    _min?: HotmartPaymentInfosMinOrderByAggregateInput
    _sum?: HotmartPaymentInfosSumOrderByAggregateInput
  }

  export type HotmartPaymentInfosScalarWhereWithAggregatesInput = {
    AND?: HotmartPaymentInfosScalarWhereWithAggregatesInput | HotmartPaymentInfosScalarWhereWithAggregatesInput[]
    OR?: HotmartPaymentInfosScalarWhereWithAggregatesInput[]
    NOT?: HotmartPaymentInfosScalarWhereWithAggregatesInput | HotmartPaymentInfosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartPaymentInfos"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartPaymentInfos"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartPaymentInfos"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartPaymentInfos"> | Date | string | null
    barcode?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    billetUrl?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    pixCode?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    pixQRCode?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    pixExpirationDate?: DateTimeNullableWithAggregatesFilter<"HotmartPaymentInfos"> | Date | string | null
    type?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    refusalReason?: StringNullableWithAggregatesFilter<"HotmartPaymentInfos"> | string | null
    installmentNumbers?: IntNullableWithAggregatesFilter<"HotmartPaymentInfos"> | number | null
    hotmartPurchaseId?: IntNullableWithAggregatesFilter<"HotmartPaymentInfos"> | number | null
  }

  export type HotmartSubscriptionWhereInput = {
    AND?: HotmartSubscriptionWhereInput | HotmartSubscriptionWhereInput[]
    OR?: HotmartSubscriptionWhereInput[]
    NOT?: HotmartSubscriptionWhereInput | HotmartSubscriptionWhereInput[]
    id?: IntFilter<"HotmartSubscription"> | number
    creationDate?: DateTimeFilter<"HotmartSubscription"> | Date | string
    updateDate?: DateTimeFilter<"HotmartSubscription"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartSubscription"> | Date | string | null
    planId?: IntNullableFilter<"HotmartSubscription"> | number | null
    subscriptionName?: StringNullableFilter<"HotmartSubscription"> | string | null
    subscriberCode?: StringNullableFilter<"HotmartSubscription"> | string | null
    subscriberStatus?: StringNullableFilter<"HotmartSubscription"> | string | null
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }

  export type HotmartSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    subscriptionName?: SortOrderInput | SortOrder
    subscriberCode?: SortOrderInput | SortOrder
    subscriberStatus?: SortOrderInput | SortOrder
    HotmartOrderNote?: HotmartOrderNoteOrderByRelationAggregateInput
  }

  export type HotmartSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotmartSubscriptionWhereInput | HotmartSubscriptionWhereInput[]
    OR?: HotmartSubscriptionWhereInput[]
    NOT?: HotmartSubscriptionWhereInput | HotmartSubscriptionWhereInput[]
    creationDate?: DateTimeFilter<"HotmartSubscription"> | Date | string
    updateDate?: DateTimeFilter<"HotmartSubscription"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartSubscription"> | Date | string | null
    planId?: IntNullableFilter<"HotmartSubscription"> | number | null
    subscriptionName?: StringNullableFilter<"HotmartSubscription"> | string | null
    subscriberCode?: StringNullableFilter<"HotmartSubscription"> | string | null
    subscriberStatus?: StringNullableFilter<"HotmartSubscription"> | string | null
    HotmartOrderNote?: HotmartOrderNoteListRelationFilter
  }, "id">

  export type HotmartSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    subscriptionName?: SortOrderInput | SortOrder
    subscriberCode?: SortOrderInput | SortOrder
    subscriberStatus?: SortOrderInput | SortOrder
    _count?: HotmartSubscriptionCountOrderByAggregateInput
    _avg?: HotmartSubscriptionAvgOrderByAggregateInput
    _max?: HotmartSubscriptionMaxOrderByAggregateInput
    _min?: HotmartSubscriptionMinOrderByAggregateInput
    _sum?: HotmartSubscriptionSumOrderByAggregateInput
  }

  export type HotmartSubscriptionScalarWhereWithAggregatesInput = {
    AND?: HotmartSubscriptionScalarWhereWithAggregatesInput | HotmartSubscriptionScalarWhereWithAggregatesInput[]
    OR?: HotmartSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: HotmartSubscriptionScalarWhereWithAggregatesInput | HotmartSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotmartSubscription"> | number
    creationDate?: DateTimeWithAggregatesFilter<"HotmartSubscription"> | Date | string
    updateDate?: DateTimeWithAggregatesFilter<"HotmartSubscription"> | Date | string
    deletionDate?: DateTimeNullableWithAggregatesFilter<"HotmartSubscription"> | Date | string | null
    planId?: IntNullableWithAggregatesFilter<"HotmartSubscription"> | number | null
    subscriptionName?: StringNullableWithAggregatesFilter<"HotmartSubscription"> | string | null
    subscriberCode?: StringNullableWithAggregatesFilter<"HotmartSubscription"> | string | null
    subscriberStatus?: StringNullableWithAggregatesFilter<"HotmartSubscription"> | string | null
  }

  export type ExternalWebhookHotmartReceiverCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    requestId: string
    eventDate: Date | string
    eventName: string
    version: string
    payload: JsonNullValueInput | InputJsonValue
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutExternalWebhookHotmartReceiverInput
  }

  export type ExternalWebhookHotmartReceiverUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    requestId: string
    eventDate: Date | string
    eventName: string
    version: string
    payload: JsonNullValueInput | InputJsonValue
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutExternalWebhookHotmartReceiverInput
  }

  export type ExternalWebhookHotmartReceiverUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutExternalWebhookHotmartReceiverNestedInput
  }

  export type ExternalWebhookHotmartReceiverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutExternalWebhookHotmartReceiverNestedInput
  }

  export type ExternalWebhookHotmartReceiverCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    requestId: string
    eventDate: Date | string
    eventName: string
    version: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type ExternalWebhookHotmartReceiverUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type ExternalWebhookHotmartReceiverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type HotmartOrderNoteCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
  }

  export type HotmartOrderNoteUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartOrderNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartProductCreateInput = {
    id: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartProductInput
  }

  export type HotmartProductUncheckedCreateInput = {
    id: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartProductInput
  }

  export type HotmartProductUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartProductNestedInput
  }

  export type HotmartProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartProductNestedInput
  }

  export type HotmartProductCreateManyInput = {
    id: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
  }

  export type HotmartProductUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotmartProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotmartAffiliatesCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
    HotmartOrderNote?: HotmartOrderNoteCreateNestedOneWithoutHotmartAffiliatesInput
  }

  export type HotmartAffiliatesUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
    hotmartOrderNoteId?: number | null
  }

  export type HotmartAffiliatesUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
    HotmartOrderNote?: HotmartOrderNoteUpdateOneWithoutHotmartAffiliatesNestedInput
  }

  export type HotmartAffiliatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartOrderNoteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartAffiliatesCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
    hotmartOrderNoteId?: number | null
  }

  export type HotmartAffiliatesUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartAffiliatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartOrderNoteId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartBuyerCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    buyerEmail: string
    buyerDocument?: string | null
    buyerName?: string | null
    buyerCheckoutPhone?: string | null
    buyerAddressCountryIso?: string | null
    buyerAddressCountry?: string | null
    buyerAddressZipCode?: string | null
    buyerAddressState?: string | null
    buyerAddressCity?: string | null
    buyerAddressNeighborhood?: string | null
    buyerAddressStreet?: string | null
    buyerAddressComplement?: string | null
    buyerAddressNumber?: string | null
    lastOrderDate?: Date | string | null
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartBuyerInput
  }

  export type HotmartBuyerUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    buyerEmail: string
    buyerDocument?: string | null
    buyerName?: string | null
    buyerCheckoutPhone?: string | null
    buyerAddressCountryIso?: string | null
    buyerAddressCountry?: string | null
    buyerAddressZipCode?: string | null
    buyerAddressState?: string | null
    buyerAddressCity?: string | null
    buyerAddressNeighborhood?: string | null
    buyerAddressStreet?: string | null
    buyerAddressComplement?: string | null
    buyerAddressNumber?: string | null
    lastOrderDate?: Date | string | null
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartBuyerInput
  }

  export type HotmartBuyerUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartBuyerNestedInput
  }

  export type HotmartBuyerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartBuyerNestedInput
  }

  export type HotmartBuyerCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    buyerEmail: string
    buyerDocument?: string | null
    buyerName?: string | null
    buyerCheckoutPhone?: string | null
    buyerAddressCountryIso?: string | null
    buyerAddressCountry?: string | null
    buyerAddressZipCode?: string | null
    buyerAddressState?: string | null
    buyerAddressCity?: string | null
    buyerAddressNeighborhood?: string | null
    buyerAddressStreet?: string | null
    buyerAddressComplement?: string | null
    buyerAddressNumber?: string | null
    lastOrderDate?: Date | string | null
  }

  export type HotmartBuyerUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartBuyerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartCommissionsCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
    HotmartPurchase?: HotmartPurchaseCreateNestedOneWithoutHotmartCommissionsInput
  }

  export type HotmartCommissionsUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: number | null
  }

  export type HotmartCommissionsUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    HotmartPurchase?: HotmartPurchaseUpdateOneWithoutHotmartCommissionsNestedInput
  }

  export type HotmartCommissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartCommissionsCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: number | null
  }

  export type HotmartCommissionsUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartCommissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPurchaseCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosCreateNestedManyWithoutHotmartPurchaseInput
    hotmartCommissions?: HotmartCommissionsCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedCreateNestedManyWithoutHotmartPurchaseInput
    hotmartCommissions?: HotmartCommissionsUncheckedCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUpdateManyWithoutHotmartPurchaseNestedInput
    hotmartCommissions?: HotmartCommissionsUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
    hotmartCommissions?: HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPurchaseCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
  }

  export type HotmartPurchaseUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartPurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartPaymentInfosCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
    HotmartPurchase?: HotmartPurchaseCreateNestedOneWithoutHotmartPaymentInfosInput
  }

  export type HotmartPaymentInfosUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
    hotmartPurchaseId?: number | null
  }

  export type HotmartPaymentInfosUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
    HotmartPurchase?: HotmartPurchaseUpdateOneWithoutHotmartPaymentInfosNestedInput
  }

  export type HotmartPaymentInfosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartPurchaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPaymentInfosCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
    hotmartPurchaseId?: number | null
  }

  export type HotmartPaymentInfosUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPaymentInfosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartPurchaseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartSubscriptionCreateInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    planId?: number | null
    subscriptionName?: string | null
    subscriberCode?: string | null
    subscriberStatus?: string | null
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartSubscriptionInput
  }

  export type HotmartSubscriptionUncheckedCreateInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    planId?: number | null
    subscriptionName?: string | null
    subscriberCode?: string | null
    subscriberStatus?: string | null
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartSubscriptionInput
  }

  export type HotmartSubscriptionUpdateInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartSubscriptionNestedInput
  }

  export type HotmartSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartSubscriptionNestedInput
  }

  export type HotmartSubscriptionCreateManyInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    planId?: number | null
    subscriptionName?: string | null
    subscriberCode?: string | null
    subscriberStatus?: string | null
  }

  export type HotmartSubscriptionUpdateManyMutationInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type HotmartOrderNoteListRelationFilter = {
    every?: HotmartOrderNoteWhereInput
    some?: HotmartOrderNoteWhereInput
    none?: HotmartOrderNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HotmartOrderNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalWebhookHotmartReceiverCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    requestId?: SortOrder
    eventDate?: SortOrder
    eventName?: SortOrder
    version?: SortOrder
    payload?: SortOrder
  }

  export type ExternalWebhookHotmartReceiverAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExternalWebhookHotmartReceiverMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    requestId?: SortOrder
    eventDate?: SortOrder
    eventName?: SortOrder
    version?: SortOrder
  }

  export type ExternalWebhookHotmartReceiverMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    requestId?: SortOrder
    eventDate?: SortOrder
    eventName?: SortOrder
    version?: SortOrder
  }

  export type ExternalWebhookHotmartReceiverSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ExternalWebhookHotmartReceiverRelationFilter = {
    is?: ExternalWebhookHotmartReceiverWhereInput
    isNot?: ExternalWebhookHotmartReceiverWhereInput
  }

  export type HotmartProductRelationFilter = {
    is?: HotmartProductWhereInput
    isNot?: HotmartProductWhereInput
  }

  export type HotmartAffiliatesListRelationFilter = {
    every?: HotmartAffiliatesWhereInput
    some?: HotmartAffiliatesWhereInput
    none?: HotmartAffiliatesWhereInput
  }

  export type HotmartBuyerRelationFilter = {
    is?: HotmartBuyerWhereInput
    isNot?: HotmartBuyerWhereInput
  }

  export type HotmartPurchaseRelationFilter = {
    is?: HotmartPurchaseWhereInput
    isNot?: HotmartPurchaseWhereInput
  }

  export type HotmartSubscriptionNullableRelationFilter = {
    is?: HotmartSubscriptionWhereInput | null
    isNot?: HotmartSubscriptionWhereInput | null
  }

  export type HotmartAffiliatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotmartOrderNoteCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    producerName?: SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrder
  }

  export type HotmartOrderNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrder
  }

  export type HotmartOrderNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    producerName?: SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrder
  }

  export type HotmartOrderNoteMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    producerName?: SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrder
  }

  export type HotmartOrderNoteSumOrderByAggregateInput = {
    id?: SortOrder
    externalWebhookHotmartReceiverId?: SortOrder
    hotmartProductId?: SortOrder
    hotmartBuyerId?: SortOrder
    hotmartPurchaseId?: SortOrder
    hotmartSubscriptionId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type HotmartProductCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    productUcode?: SortOrder
    productName?: SortOrder
    productHasCoProduction?: SortOrder
  }

  export type HotmartProductAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotmartProductMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    productUcode?: SortOrder
    productName?: SortOrder
    productHasCoProduction?: SortOrder
  }

  export type HotmartProductMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    productUcode?: SortOrder
    productName?: SortOrder
    productHasCoProduction?: SortOrder
  }

  export type HotmartProductSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type HotmartOrderNoteNullableRelationFilter = {
    is?: HotmartOrderNoteWhereInput | null
    isNot?: HotmartOrderNoteWhereInput | null
  }

  export type HotmartAffiliatesCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    affiliateCode?: SortOrder
    affiliateName?: SortOrder
    hotmartOrderNoteId?: SortOrder
  }

  export type HotmartAffiliatesAvgOrderByAggregateInput = {
    id?: SortOrder
    hotmartOrderNoteId?: SortOrder
  }

  export type HotmartAffiliatesMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    affiliateCode?: SortOrder
    affiliateName?: SortOrder
    hotmartOrderNoteId?: SortOrder
  }

  export type HotmartAffiliatesMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    lastOrderDate?: SortOrder
    affiliateCode?: SortOrder
    affiliateName?: SortOrder
    hotmartOrderNoteId?: SortOrder
  }

  export type HotmartAffiliatesSumOrderByAggregateInput = {
    id?: SortOrder
    hotmartOrderNoteId?: SortOrder
  }

  export type HotmartBuyerCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    buyerEmail?: SortOrder
    buyerDocument?: SortOrder
    buyerName?: SortOrder
    buyerCheckoutPhone?: SortOrder
    buyerAddressCountryIso?: SortOrder
    buyerAddressCountry?: SortOrder
    buyerAddressZipCode?: SortOrder
    buyerAddressState?: SortOrder
    buyerAddressCity?: SortOrder
    buyerAddressNeighborhood?: SortOrder
    buyerAddressStreet?: SortOrder
    buyerAddressComplement?: SortOrder
    buyerAddressNumber?: SortOrder
    lastOrderDate?: SortOrder
  }

  export type HotmartBuyerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotmartBuyerMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    buyerEmail?: SortOrder
    buyerDocument?: SortOrder
    buyerName?: SortOrder
    buyerCheckoutPhone?: SortOrder
    buyerAddressCountryIso?: SortOrder
    buyerAddressCountry?: SortOrder
    buyerAddressZipCode?: SortOrder
    buyerAddressState?: SortOrder
    buyerAddressCity?: SortOrder
    buyerAddressNeighborhood?: SortOrder
    buyerAddressStreet?: SortOrder
    buyerAddressComplement?: SortOrder
    buyerAddressNumber?: SortOrder
    lastOrderDate?: SortOrder
  }

  export type HotmartBuyerMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    buyerEmail?: SortOrder
    buyerDocument?: SortOrder
    buyerName?: SortOrder
    buyerCheckoutPhone?: SortOrder
    buyerAddressCountryIso?: SortOrder
    buyerAddressCountry?: SortOrder
    buyerAddressZipCode?: SortOrder
    buyerAddressState?: SortOrder
    buyerAddressCity?: SortOrder
    buyerAddressNeighborhood?: SortOrder
    buyerAddressStreet?: SortOrder
    buyerAddressComplement?: SortOrder
    buyerAddressNumber?: SortOrder
    lastOrderDate?: SortOrder
  }

  export type HotmartBuyerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartPurchaseNullableRelationFilter = {
    is?: HotmartPurchaseWhereInput | null
    isNot?: HotmartPurchaseWhereInput | null
  }

  export type HotmartCommissionsCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    sourceName?: SortOrder
    value?: SortOrder
    currencyValue?: SortOrder
    convertedToCurrency?: SortOrder
    convertedvalue?: SortOrder
    currencyConvertionRate?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartCommissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    convertedvalue?: SortOrder
    currencyConvertionRate?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartCommissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    sourceName?: SortOrder
    value?: SortOrder
    currencyValue?: SortOrder
    convertedToCurrency?: SortOrder
    convertedvalue?: SortOrder
    currencyConvertionRate?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartCommissionsMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    sourceName?: SortOrder
    value?: SortOrder
    currencyValue?: SortOrder
    convertedToCurrency?: SortOrder
    convertedvalue?: SortOrder
    currencyConvertionRate?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartCommissionsSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    convertedvalue?: SortOrder
    currencyConvertionRate?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type HotmartPaymentInfosListRelationFilter = {
    every?: HotmartPaymentInfosWhereInput
    some?: HotmartPaymentInfosWhereInput
    none?: HotmartPaymentInfosWhereInput
  }

  export type HotmartCommissionsListRelationFilter = {
    every?: HotmartCommissionsWhereInput
    some?: HotmartCommissionsWhereInput
    none?: HotmartCommissionsWhereInput
  }

  export type HotmartPaymentInfosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotmartCommissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotmartPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    orderDate?: SortOrder
    approvedDate?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    fullPriceValue?: SortOrder
    fullPriceCurrency?: SortOrder
    originalPriceValue?: SortOrder
    originalPriceCurrency?: SortOrder
    priceValue?: SortOrder
    priceCurrency?: SortOrder
    offerCode?: SortOrder
    recurrencyNumber?: SortOrder
    subscriptionAnticipationPurchase?: SortOrder
    checkoutCountryName?: SortOrder
    checkoutCountryISO?: SortOrder
    utmCode?: SortOrder
    isOrderBump?: SortOrder
    originalTransactionId?: SortOrder
    nextChargeDate?: SortOrder
  }

  export type HotmartPurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    fullPriceValue?: SortOrder
    originalPriceValue?: SortOrder
    priceValue?: SortOrder
    recurrencyNumber?: SortOrder
  }

  export type HotmartPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    orderDate?: SortOrder
    approvedDate?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    fullPriceValue?: SortOrder
    fullPriceCurrency?: SortOrder
    originalPriceValue?: SortOrder
    originalPriceCurrency?: SortOrder
    priceValue?: SortOrder
    priceCurrency?: SortOrder
    offerCode?: SortOrder
    recurrencyNumber?: SortOrder
    subscriptionAnticipationPurchase?: SortOrder
    checkoutCountryName?: SortOrder
    checkoutCountryISO?: SortOrder
    utmCode?: SortOrder
    isOrderBump?: SortOrder
    originalTransactionId?: SortOrder
    nextChargeDate?: SortOrder
  }

  export type HotmartPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    orderDate?: SortOrder
    approvedDate?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    fullPriceValue?: SortOrder
    fullPriceCurrency?: SortOrder
    originalPriceValue?: SortOrder
    originalPriceCurrency?: SortOrder
    priceValue?: SortOrder
    priceCurrency?: SortOrder
    offerCode?: SortOrder
    recurrencyNumber?: SortOrder
    subscriptionAnticipationPurchase?: SortOrder
    checkoutCountryName?: SortOrder
    checkoutCountryISO?: SortOrder
    utmCode?: SortOrder
    isOrderBump?: SortOrder
    originalTransactionId?: SortOrder
    nextChargeDate?: SortOrder
  }

  export type HotmartPurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    fullPriceValue?: SortOrder
    originalPriceValue?: SortOrder
    priceValue?: SortOrder
    recurrencyNumber?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type HotmartPaymentInfosCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    barcode?: SortOrder
    billetUrl?: SortOrder
    pixCode?: SortOrder
    pixQRCode?: SortOrder
    pixExpirationDate?: SortOrder
    type?: SortOrder
    refusalReason?: SortOrder
    installmentNumbers?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartPaymentInfosAvgOrderByAggregateInput = {
    id?: SortOrder
    installmentNumbers?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartPaymentInfosMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    barcode?: SortOrder
    billetUrl?: SortOrder
    pixCode?: SortOrder
    pixQRCode?: SortOrder
    pixExpirationDate?: SortOrder
    type?: SortOrder
    refusalReason?: SortOrder
    installmentNumbers?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartPaymentInfosMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    barcode?: SortOrder
    billetUrl?: SortOrder
    pixCode?: SortOrder
    pixQRCode?: SortOrder
    pixExpirationDate?: SortOrder
    type?: SortOrder
    refusalReason?: SortOrder
    installmentNumbers?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartPaymentInfosSumOrderByAggregateInput = {
    id?: SortOrder
    installmentNumbers?: SortOrder
    hotmartPurchaseId?: SortOrder
  }

  export type HotmartSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    planId?: SortOrder
    subscriptionName?: SortOrder
    subscriberCode?: SortOrder
    subscriberStatus?: SortOrder
  }

  export type HotmartSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
  }

  export type HotmartSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    planId?: SortOrder
    subscriptionName?: SortOrder
    subscriberCode?: SortOrder
    subscriberStatus?: SortOrder
  }

  export type HotmartSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    creationDate?: SortOrder
    updateDate?: SortOrder
    deletionDate?: SortOrder
    planId?: SortOrder
    subscriptionName?: SortOrder
    subscriberCode?: SortOrder
    subscriberStatus?: SortOrder
  }

  export type HotmartSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
  }

  export type HotmartOrderNoteCreateNestedManyWithoutExternalWebhookHotmartReceiverInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput> | HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput[] | HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput[]
    createMany?: HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUncheckedCreateNestedManyWithoutExternalWebhookHotmartReceiverInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput> | HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput[] | HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput[]
    createMany?: HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type HotmartOrderNoteUpdateManyWithoutExternalWebhookHotmartReceiverNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput> | HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput[] | HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput[]
    createMany?: HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpdateManyWithWhereWithoutExternalWebhookHotmartReceiverInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutExternalWebhookHotmartReceiverNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput> | HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput[] | HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput[]
    createMany?: HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutExternalWebhookHotmartReceiverInput | HotmartOrderNoteUpdateManyWithWhereWithoutExternalWebhookHotmartReceiverInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput = {
    create?: XOR<ExternalWebhookHotmartReceiverCreateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: ExternalWebhookHotmartReceiverCreateOrConnectWithoutHotmartOrderNoteInput
    connect?: ExternalWebhookHotmartReceiverWhereUniqueInput
  }

  export type HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartProductCreateWithoutHotmartOrderNoteInput, HotmartProductUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartProductCreateOrConnectWithoutHotmartOrderNoteInput
    connect?: HotmartProductWhereUniqueInput
  }

  export type HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput> | HotmartAffiliatesCreateWithoutHotmartOrderNoteInput[] | HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput[]
    connectOrCreate?: HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput | HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput[]
    createMany?: HotmartAffiliatesCreateManyHotmartOrderNoteInputEnvelope
    connect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
  }

  export type HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartBuyerCreateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartBuyerCreateOrConnectWithoutHotmartOrderNoteInput
    connect?: HotmartBuyerWhereUniqueInput
  }

  export type HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartOrderNoteInput
    connect?: HotmartPurchaseWhereUniqueInput
  }

  export type HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartSubscriptionCreateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartSubscriptionCreateOrConnectWithoutHotmartOrderNoteInput
    connect?: HotmartSubscriptionWhereUniqueInput
  }

  export type HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput = {
    create?: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput> | HotmartAffiliatesCreateWithoutHotmartOrderNoteInput[] | HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput[]
    connectOrCreate?: HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput | HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput[]
    createMany?: HotmartAffiliatesCreateManyHotmartOrderNoteInputEnvelope
    connect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<ExternalWebhookHotmartReceiverCreateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: ExternalWebhookHotmartReceiverCreateOrConnectWithoutHotmartOrderNoteInput
    upsert?: ExternalWebhookHotmartReceiverUpsertWithoutHotmartOrderNoteInput
    connect?: ExternalWebhookHotmartReceiverWhereUniqueInput
    update?: XOR<XOR<ExternalWebhookHotmartReceiverUpdateToOneWithWhereWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUpdateWithoutHotmartOrderNoteInput>, ExternalWebhookHotmartReceiverUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartProductCreateWithoutHotmartOrderNoteInput, HotmartProductUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartProductCreateOrConnectWithoutHotmartOrderNoteInput
    upsert?: HotmartProductUpsertWithoutHotmartOrderNoteInput
    connect?: HotmartProductWhereUniqueInput
    update?: XOR<XOR<HotmartProductUpdateToOneWithWhereWithoutHotmartOrderNoteInput, HotmartProductUpdateWithoutHotmartOrderNoteInput>, HotmartProductUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput> | HotmartAffiliatesCreateWithoutHotmartOrderNoteInput[] | HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput[]
    connectOrCreate?: HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput | HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput[]
    upsert?: HotmartAffiliatesUpsertWithWhereUniqueWithoutHotmartOrderNoteInput | HotmartAffiliatesUpsertWithWhereUniqueWithoutHotmartOrderNoteInput[]
    createMany?: HotmartAffiliatesCreateManyHotmartOrderNoteInputEnvelope
    set?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    disconnect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    delete?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    connect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    update?: HotmartAffiliatesUpdateWithWhereUniqueWithoutHotmartOrderNoteInput | HotmartAffiliatesUpdateWithWhereUniqueWithoutHotmartOrderNoteInput[]
    updateMany?: HotmartAffiliatesUpdateManyWithWhereWithoutHotmartOrderNoteInput | HotmartAffiliatesUpdateManyWithWhereWithoutHotmartOrderNoteInput[]
    deleteMany?: HotmartAffiliatesScalarWhereInput | HotmartAffiliatesScalarWhereInput[]
  }

  export type HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartBuyerCreateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartBuyerCreateOrConnectWithoutHotmartOrderNoteInput
    upsert?: HotmartBuyerUpsertWithoutHotmartOrderNoteInput
    connect?: HotmartBuyerWhereUniqueInput
    update?: XOR<XOR<HotmartBuyerUpdateToOneWithWhereWithoutHotmartOrderNoteInput, HotmartBuyerUpdateWithoutHotmartOrderNoteInput>, HotmartBuyerUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartOrderNoteInput
    upsert?: HotmartPurchaseUpsertWithoutHotmartOrderNoteInput
    connect?: HotmartPurchaseWhereUniqueInput
    update?: XOR<XOR<HotmartPurchaseUpdateToOneWithWhereWithoutHotmartOrderNoteInput, HotmartPurchaseUpdateWithoutHotmartOrderNoteInput>, HotmartPurchaseUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartSubscriptionCreateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedCreateWithoutHotmartOrderNoteInput>
    connectOrCreate?: HotmartSubscriptionCreateOrConnectWithoutHotmartOrderNoteInput
    upsert?: HotmartSubscriptionUpsertWithoutHotmartOrderNoteInput
    disconnect?: HotmartSubscriptionWhereInput | boolean
    delete?: HotmartSubscriptionWhereInput | boolean
    connect?: HotmartSubscriptionWhereUniqueInput
    update?: XOR<XOR<HotmartSubscriptionUpdateToOneWithWhereWithoutHotmartOrderNoteInput, HotmartSubscriptionUpdateWithoutHotmartOrderNoteInput>, HotmartSubscriptionUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput = {
    create?: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput> | HotmartAffiliatesCreateWithoutHotmartOrderNoteInput[] | HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput[]
    connectOrCreate?: HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput | HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput[]
    upsert?: HotmartAffiliatesUpsertWithWhereUniqueWithoutHotmartOrderNoteInput | HotmartAffiliatesUpsertWithWhereUniqueWithoutHotmartOrderNoteInput[]
    createMany?: HotmartAffiliatesCreateManyHotmartOrderNoteInputEnvelope
    set?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    disconnect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    delete?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    connect?: HotmartAffiliatesWhereUniqueInput | HotmartAffiliatesWhereUniqueInput[]
    update?: HotmartAffiliatesUpdateWithWhereUniqueWithoutHotmartOrderNoteInput | HotmartAffiliatesUpdateWithWhereUniqueWithoutHotmartOrderNoteInput[]
    updateMany?: HotmartAffiliatesUpdateManyWithWhereWithoutHotmartOrderNoteInput | HotmartAffiliatesUpdateManyWithWhereWithoutHotmartOrderNoteInput[]
    deleteMany?: HotmartAffiliatesScalarWhereInput | HotmartAffiliatesScalarWhereInput[]
  }

  export type HotmartOrderNoteCreateNestedManyWithoutHotmartProductInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput> | HotmartOrderNoteCreateWithoutHotmartProductInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput | HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartProductInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartProductInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput> | HotmartOrderNoteCreateWithoutHotmartProductInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput | HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartProductInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type HotmartOrderNoteUpdateManyWithoutHotmartProductNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput> | HotmartOrderNoteCreateWithoutHotmartProductInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput | HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartProductInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartProductInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartProductInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartProductInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartProductInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartProductInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartProductInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartProductNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput> | HotmartOrderNoteCreateWithoutHotmartProductInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput | HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartProductInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartProductInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartProductInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartProductInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartProductInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartProductInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartProductInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartOrderNoteCreateNestedOneWithoutHotmartAffiliatesInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedCreateWithoutHotmartAffiliatesInput>
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartAffiliatesInput
    connect?: HotmartOrderNoteWhereUniqueInput
  }

  export type HotmartOrderNoteUpdateOneWithoutHotmartAffiliatesNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedCreateWithoutHotmartAffiliatesInput>
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartAffiliatesInput
    upsert?: HotmartOrderNoteUpsertWithoutHotmartAffiliatesInput
    disconnect?: HotmartOrderNoteWhereInput | boolean
    delete?: HotmartOrderNoteWhereInput | boolean
    connect?: HotmartOrderNoteWhereUniqueInput
    update?: XOR<XOR<HotmartOrderNoteUpdateToOneWithWhereWithoutHotmartAffiliatesInput, HotmartOrderNoteUpdateWithoutHotmartAffiliatesInput>, HotmartOrderNoteUncheckedUpdateWithoutHotmartAffiliatesInput>
  }

  export type HotmartOrderNoteCreateNestedManyWithoutHotmartBuyerInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput> | HotmartOrderNoteCreateWithoutHotmartBuyerInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput | HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartBuyerInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartBuyerInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput> | HotmartOrderNoteCreateWithoutHotmartBuyerInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput | HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartBuyerInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUpdateManyWithoutHotmartBuyerNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput> | HotmartOrderNoteCreateWithoutHotmartBuyerInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput | HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartBuyerInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartBuyerInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartBuyerInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartBuyerInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartBuyerInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartBuyerInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartBuyerInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartBuyerNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput> | HotmartOrderNoteCreateWithoutHotmartBuyerInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput | HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartBuyerInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartBuyerInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartBuyerInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartBuyerInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartBuyerInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartBuyerInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartBuyerInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartPurchaseCreateNestedOneWithoutHotmartCommissionsInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedCreateWithoutHotmartCommissionsInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartCommissionsInput
    connect?: HotmartPurchaseWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type HotmartPurchaseUpdateOneWithoutHotmartCommissionsNestedInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedCreateWithoutHotmartCommissionsInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartCommissionsInput
    upsert?: HotmartPurchaseUpsertWithoutHotmartCommissionsInput
    disconnect?: HotmartPurchaseWhereInput | boolean
    delete?: HotmartPurchaseWhereInput | boolean
    connect?: HotmartPurchaseWhereUniqueInput
    update?: XOR<XOR<HotmartPurchaseUpdateToOneWithWhereWithoutHotmartCommissionsInput, HotmartPurchaseUpdateWithoutHotmartCommissionsInput>, HotmartPurchaseUncheckedUpdateWithoutHotmartCommissionsInput>
  }

  export type HotmartPaymentInfosCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput> | HotmartPaymentInfosCreateWithoutHotmartPurchaseInput[] | HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput | HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartPaymentInfosCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
  }

  export type HotmartCommissionsCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput> | HotmartCommissionsCreateWithoutHotmartPurchaseInput[] | HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput | HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartCommissionsCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
  }

  export type HotmartOrderNoteCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput> | HotmartOrderNoteCreateWithoutHotmartPurchaseInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput | HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartPaymentInfosUncheckedCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput> | HotmartPaymentInfosCreateWithoutHotmartPurchaseInput[] | HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput | HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartPaymentInfosCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
  }

  export type HotmartCommissionsUncheckedCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput> | HotmartCommissionsCreateWithoutHotmartPurchaseInput[] | HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput | HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartCommissionsCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
  }

  export type HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartPurchaseInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput> | HotmartOrderNoteCreateWithoutHotmartPurchaseInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput | HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartPurchaseInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type HotmartPaymentInfosUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput> | HotmartPaymentInfosCreateWithoutHotmartPurchaseInput[] | HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput | HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartPaymentInfosUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartPaymentInfosUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartPaymentInfosCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    disconnect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    delete?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    connect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    update?: HotmartPaymentInfosUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartPaymentInfosUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartPaymentInfosUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartPaymentInfosUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartPaymentInfosScalarWhereInput | HotmartPaymentInfosScalarWhereInput[]
  }

  export type HotmartCommissionsUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput> | HotmartCommissionsCreateWithoutHotmartPurchaseInput[] | HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput | HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartCommissionsUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartCommissionsUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartCommissionsCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    disconnect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    delete?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    connect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    update?: HotmartCommissionsUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartCommissionsUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartCommissionsUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartCommissionsUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartCommissionsScalarWhereInput | HotmartCommissionsScalarWhereInput[]
  }

  export type HotmartOrderNoteUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput> | HotmartOrderNoteCreateWithoutHotmartPurchaseInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput | HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput> | HotmartPaymentInfosCreateWithoutHotmartPurchaseInput[] | HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput | HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartPaymentInfosUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartPaymentInfosUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartPaymentInfosCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    disconnect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    delete?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    connect?: HotmartPaymentInfosWhereUniqueInput | HotmartPaymentInfosWhereUniqueInput[]
    update?: HotmartPaymentInfosUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartPaymentInfosUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartPaymentInfosUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartPaymentInfosUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartPaymentInfosScalarWhereInput | HotmartPaymentInfosScalarWhereInput[]
  }

  export type HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput> | HotmartCommissionsCreateWithoutHotmartPurchaseInput[] | HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput | HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartCommissionsUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartCommissionsUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartCommissionsCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    disconnect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    delete?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    connect?: HotmartCommissionsWhereUniqueInput | HotmartCommissionsWhereUniqueInput[]
    update?: HotmartCommissionsUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartCommissionsUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartCommissionsUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartCommissionsUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartCommissionsScalarWhereInput | HotmartCommissionsScalarWhereInput[]
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput> | HotmartOrderNoteCreateWithoutHotmartPurchaseInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput | HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartPurchaseInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartPurchaseInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartPurchaseInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartPurchaseInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartPurchaseInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartPurchaseInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartPurchaseInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartPurchaseCreateNestedOneWithoutHotmartPaymentInfosInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedCreateWithoutHotmartPaymentInfosInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartPaymentInfosInput
    connect?: HotmartPurchaseWhereUniqueInput
  }

  export type HotmartPurchaseUpdateOneWithoutHotmartPaymentInfosNestedInput = {
    create?: XOR<HotmartPurchaseCreateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedCreateWithoutHotmartPaymentInfosInput>
    connectOrCreate?: HotmartPurchaseCreateOrConnectWithoutHotmartPaymentInfosInput
    upsert?: HotmartPurchaseUpsertWithoutHotmartPaymentInfosInput
    disconnect?: HotmartPurchaseWhereInput | boolean
    delete?: HotmartPurchaseWhereInput | boolean
    connect?: HotmartPurchaseWhereUniqueInput
    update?: XOR<XOR<HotmartPurchaseUpdateToOneWithWhereWithoutHotmartPaymentInfosInput, HotmartPurchaseUpdateWithoutHotmartPaymentInfosInput>, HotmartPurchaseUncheckedUpdateWithoutHotmartPaymentInfosInput>
  }

  export type HotmartOrderNoteCreateNestedManyWithoutHotmartSubscriptionInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput> | HotmartOrderNoteCreateWithoutHotmartSubscriptionInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput | HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartSubscriptionInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartSubscriptionInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput> | HotmartOrderNoteCreateWithoutHotmartSubscriptionInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput | HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartSubscriptionInputEnvelope
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
  }

  export type HotmartOrderNoteUpdateManyWithoutHotmartSubscriptionNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput> | HotmartOrderNoteCreateWithoutHotmartSubscriptionInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput | HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartSubscriptionInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartSubscriptionInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartSubscriptionInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartSubscriptionInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartSubscriptionInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartSubscriptionInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartSubscriptionInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartSubscriptionNestedInput = {
    create?: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput> | HotmartOrderNoteCreateWithoutHotmartSubscriptionInput[] | HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput[]
    connectOrCreate?: HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput | HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput[]
    upsert?: HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartSubscriptionInput | HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartSubscriptionInput[]
    createMany?: HotmartOrderNoteCreateManyHotmartSubscriptionInputEnvelope
    set?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    disconnect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    delete?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    connect?: HotmartOrderNoteWhereUniqueInput | HotmartOrderNoteWhereUniqueInput[]
    update?: HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartSubscriptionInput | HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartSubscriptionInput[]
    updateMany?: HotmartOrderNoteUpdateManyWithWhereWithoutHotmartSubscriptionInput | HotmartOrderNoteUpdateManyWithWhereWithoutHotmartSubscriptionInput[]
    deleteMany?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteCreateOrConnectWithoutExternalWebhookHotmartReceiverInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput>
  }

  export type HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInputEnvelope = {
    data: HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInput | HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInput[]
    skipDuplicates?: boolean
  }

  export type HotmartOrderNoteUpsertWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput = {
    where: HotmartOrderNoteWhereUniqueInput
    update: XOR<HotmartOrderNoteUpdateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedUpdateWithoutExternalWebhookHotmartReceiverInput>
    create: XOR<HotmartOrderNoteCreateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedCreateWithoutExternalWebhookHotmartReceiverInput>
  }

  export type HotmartOrderNoteUpdateWithWhereUniqueWithoutExternalWebhookHotmartReceiverInput = {
    where: HotmartOrderNoteWhereUniqueInput
    data: XOR<HotmartOrderNoteUpdateWithoutExternalWebhookHotmartReceiverInput, HotmartOrderNoteUncheckedUpdateWithoutExternalWebhookHotmartReceiverInput>
  }

  export type HotmartOrderNoteUpdateManyWithWhereWithoutExternalWebhookHotmartReceiverInput = {
    where: HotmartOrderNoteScalarWhereInput
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyWithoutExternalWebhookHotmartReceiverInput>
  }

  export type HotmartOrderNoteScalarWhereInput = {
    AND?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
    OR?: HotmartOrderNoteScalarWhereInput[]
    NOT?: HotmartOrderNoteScalarWhereInput | HotmartOrderNoteScalarWhereInput[]
    id?: IntFilter<"HotmartOrderNote"> | number
    creationDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    updateDate?: DateTimeFilter<"HotmartOrderNote"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartOrderNote"> | Date | string | null
    externalWebhookHotmartReceiverId?: IntFilter<"HotmartOrderNote"> | number
    hotmartProductId?: IntFilter<"HotmartOrderNote"> | number
    hotmartBuyerId?: IntFilter<"HotmartOrderNote"> | number
    producerName?: StringNullableFilter<"HotmartOrderNote"> | string | null
    hotmartPurchaseId?: IntFilter<"HotmartOrderNote"> | number
    hotmartSubscriptionId?: IntNullableFilter<"HotmartOrderNote"> | number | null
  }

  export type ExternalWebhookHotmartReceiverCreateWithoutHotmartOrderNoteInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    requestId: string
    eventDate: Date | string
    eventName: string
    version: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type ExternalWebhookHotmartReceiverUncheckedCreateWithoutHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    requestId: string
    eventDate: Date | string
    eventName: string
    version: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type ExternalWebhookHotmartReceiverCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: ExternalWebhookHotmartReceiverWhereUniqueInput
    create: XOR<ExternalWebhookHotmartReceiverCreateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartProductCreateWithoutHotmartOrderNoteInput = {
    id: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
  }

  export type HotmartProductUncheckedCreateWithoutHotmartOrderNoteInput = {
    id: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    productUcode: string
    productName: string
    productHasCoProduction: boolean
  }

  export type HotmartProductCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: HotmartProductWhereUniqueInput
    create: XOR<HotmartProductCreateWithoutHotmartOrderNoteInput, HotmartProductUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesCreateWithoutHotmartOrderNoteInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
  }

  export type HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
  }

  export type HotmartAffiliatesCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: HotmartAffiliatesWhereUniqueInput
    create: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesCreateManyHotmartOrderNoteInputEnvelope = {
    data: HotmartAffiliatesCreateManyHotmartOrderNoteInput | HotmartAffiliatesCreateManyHotmartOrderNoteInput[]
    skipDuplicates?: boolean
  }

  export type HotmartBuyerCreateWithoutHotmartOrderNoteInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    buyerEmail: string
    buyerDocument?: string | null
    buyerName?: string | null
    buyerCheckoutPhone?: string | null
    buyerAddressCountryIso?: string | null
    buyerAddressCountry?: string | null
    buyerAddressZipCode?: string | null
    buyerAddressState?: string | null
    buyerAddressCity?: string | null
    buyerAddressNeighborhood?: string | null
    buyerAddressStreet?: string | null
    buyerAddressComplement?: string | null
    buyerAddressNumber?: string | null
    lastOrderDate?: Date | string | null
  }

  export type HotmartBuyerUncheckedCreateWithoutHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    buyerEmail: string
    buyerDocument?: string | null
    buyerName?: string | null
    buyerCheckoutPhone?: string | null
    buyerAddressCountryIso?: string | null
    buyerAddressCountry?: string | null
    buyerAddressZipCode?: string | null
    buyerAddressState?: string | null
    buyerAddressCity?: string | null
    buyerAddressNeighborhood?: string | null
    buyerAddressStreet?: string | null
    buyerAddressComplement?: string | null
    buyerAddressNumber?: string | null
    lastOrderDate?: Date | string | null
  }

  export type HotmartBuyerCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: HotmartBuyerWhereUniqueInput
    create: XOR<HotmartBuyerCreateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartPurchaseCreateWithoutHotmartOrderNoteInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosCreateNestedManyWithoutHotmartPurchaseInput
    hotmartCommissions?: HotmartCommissionsCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseUncheckedCreateWithoutHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedCreateNestedManyWithoutHotmartPurchaseInput
    hotmartCommissions?: HotmartCommissionsUncheckedCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: HotmartPurchaseWhereUniqueInput
    create: XOR<HotmartPurchaseCreateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartSubscriptionCreateWithoutHotmartOrderNoteInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    planId?: number | null
    subscriptionName?: string | null
    subscriberCode?: string | null
    subscriberStatus?: string | null
  }

  export type HotmartSubscriptionUncheckedCreateWithoutHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    planId?: number | null
    subscriptionName?: string | null
    subscriberCode?: string | null
    subscriberStatus?: string | null
  }

  export type HotmartSubscriptionCreateOrConnectWithoutHotmartOrderNoteInput = {
    where: HotmartSubscriptionWhereUniqueInput
    create: XOR<HotmartSubscriptionCreateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type ExternalWebhookHotmartReceiverUpsertWithoutHotmartOrderNoteInput = {
    update: XOR<ExternalWebhookHotmartReceiverUpdateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<ExternalWebhookHotmartReceiverCreateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedCreateWithoutHotmartOrderNoteInput>
    where?: ExternalWebhookHotmartReceiverWhereInput
  }

  export type ExternalWebhookHotmartReceiverUpdateToOneWithWhereWithoutHotmartOrderNoteInput = {
    where?: ExternalWebhookHotmartReceiverWhereInput
    data: XOR<ExternalWebhookHotmartReceiverUpdateWithoutHotmartOrderNoteInput, ExternalWebhookHotmartReceiverUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type ExternalWebhookHotmartReceiverUpdateWithoutHotmartOrderNoteInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type ExternalWebhookHotmartReceiverUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestId?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eventName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type HotmartProductUpsertWithoutHotmartOrderNoteInput = {
    update: XOR<HotmartProductUpdateWithoutHotmartOrderNoteInput, HotmartProductUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<HotmartProductCreateWithoutHotmartOrderNoteInput, HotmartProductUncheckedCreateWithoutHotmartOrderNoteInput>
    where?: HotmartProductWhereInput
  }

  export type HotmartProductUpdateToOneWithWhereWithoutHotmartOrderNoteInput = {
    where?: HotmartProductWhereInput
    data: XOR<HotmartProductUpdateWithoutHotmartOrderNoteInput, HotmartProductUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartProductUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotmartProductUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productUcode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productHasCoProduction?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotmartAffiliatesUpsertWithWhereUniqueWithoutHotmartOrderNoteInput = {
    where: HotmartAffiliatesWhereUniqueInput
    update: XOR<HotmartAffiliatesUpdateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<HotmartAffiliatesCreateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedCreateWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesUpdateWithWhereUniqueWithoutHotmartOrderNoteInput = {
    where: HotmartAffiliatesWhereUniqueInput
    data: XOR<HotmartAffiliatesUpdateWithoutHotmartOrderNoteInput, HotmartAffiliatesUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesUpdateManyWithWhereWithoutHotmartOrderNoteInput = {
    where: HotmartAffiliatesScalarWhereInput
    data: XOR<HotmartAffiliatesUpdateManyMutationInput, HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteInput>
  }

  export type HotmartAffiliatesScalarWhereInput = {
    AND?: HotmartAffiliatesScalarWhereInput | HotmartAffiliatesScalarWhereInput[]
    OR?: HotmartAffiliatesScalarWhereInput[]
    NOT?: HotmartAffiliatesScalarWhereInput | HotmartAffiliatesScalarWhereInput[]
    id?: IntFilter<"HotmartAffiliates"> | number
    creationDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    updateDate?: DateTimeFilter<"HotmartAffiliates"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    lastOrderDate?: DateTimeNullableFilter<"HotmartAffiliates"> | Date | string | null
    affiliateCode?: StringNullableFilter<"HotmartAffiliates"> | string | null
    affiliateName?: StringNullableFilter<"HotmartAffiliates"> | string | null
    hotmartOrderNoteId?: IntNullableFilter<"HotmartAffiliates"> | number | null
  }

  export type HotmartBuyerUpsertWithoutHotmartOrderNoteInput = {
    update: XOR<HotmartBuyerUpdateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<HotmartBuyerCreateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedCreateWithoutHotmartOrderNoteInput>
    where?: HotmartBuyerWhereInput
  }

  export type HotmartBuyerUpdateToOneWithWhereWithoutHotmartOrderNoteInput = {
    where?: HotmartBuyerWhereInput
    data: XOR<HotmartBuyerUpdateWithoutHotmartOrderNoteInput, HotmartBuyerUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartBuyerUpdateWithoutHotmartOrderNoteInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartBuyerUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    buyerCheckoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountryIso?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCountry?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressState?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressCity?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNeighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressStreet?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressComplement?: NullableStringFieldUpdateOperationsInput | string | null
    buyerAddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotmartPurchaseUpsertWithoutHotmartOrderNoteInput = {
    update: XOR<HotmartPurchaseUpdateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<HotmartPurchaseCreateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedCreateWithoutHotmartOrderNoteInput>
    where?: HotmartPurchaseWhereInput
  }

  export type HotmartPurchaseUpdateToOneWithWhereWithoutHotmartOrderNoteInput = {
    where?: HotmartPurchaseWhereInput
    data: XOR<HotmartPurchaseUpdateWithoutHotmartOrderNoteInput, HotmartPurchaseUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartPurchaseUpdateWithoutHotmartOrderNoteInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUpdateManyWithoutHotmartPurchaseNestedInput
    hotmartCommissions?: HotmartCommissionsUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPurchaseUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
    hotmartCommissions?: HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartSubscriptionUpsertWithoutHotmartOrderNoteInput = {
    update: XOR<HotmartSubscriptionUpdateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedUpdateWithoutHotmartOrderNoteInput>
    create: XOR<HotmartSubscriptionCreateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedCreateWithoutHotmartOrderNoteInput>
    where?: HotmartSubscriptionWhereInput
  }

  export type HotmartSubscriptionUpdateToOneWithWhereWithoutHotmartOrderNoteInput = {
    where?: HotmartSubscriptionWhereInput
    data: XOR<HotmartSubscriptionUpdateWithoutHotmartOrderNoteInput, HotmartSubscriptionUncheckedUpdateWithoutHotmartOrderNoteInput>
  }

  export type HotmartSubscriptionUpdateWithoutHotmartOrderNoteInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartSubscriptionUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionName?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberCode?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartOrderNoteCreateWithoutHotmartProductInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteCreateOrConnectWithoutHotmartProductInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput>
  }

  export type HotmartOrderNoteCreateManyHotmartProductInputEnvelope = {
    data: HotmartOrderNoteCreateManyHotmartProductInput | HotmartOrderNoteCreateManyHotmartProductInput[]
    skipDuplicates?: boolean
  }

  export type HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartProductInput = {
    where: HotmartOrderNoteWhereUniqueInput
    update: XOR<HotmartOrderNoteUpdateWithoutHotmartProductInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartProductInput>
    create: XOR<HotmartOrderNoteCreateWithoutHotmartProductInput, HotmartOrderNoteUncheckedCreateWithoutHotmartProductInput>
  }

  export type HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartProductInput = {
    where: HotmartOrderNoteWhereUniqueInput
    data: XOR<HotmartOrderNoteUpdateWithoutHotmartProductInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartProductInput>
  }

  export type HotmartOrderNoteUpdateManyWithWhereWithoutHotmartProductInput = {
    where: HotmartOrderNoteScalarWhereInput
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyWithoutHotmartProductInput>
  }

  export type HotmartOrderNoteCreateWithoutHotmartAffiliatesInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutHotmartAffiliatesInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
  }

  export type HotmartOrderNoteCreateOrConnectWithoutHotmartAffiliatesInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedCreateWithoutHotmartAffiliatesInput>
  }

  export type HotmartOrderNoteUpsertWithoutHotmartAffiliatesInput = {
    update: XOR<HotmartOrderNoteUpdateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartAffiliatesInput>
    create: XOR<HotmartOrderNoteCreateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedCreateWithoutHotmartAffiliatesInput>
    where?: HotmartOrderNoteWhereInput
  }

  export type HotmartOrderNoteUpdateToOneWithWhereWithoutHotmartAffiliatesInput = {
    where?: HotmartOrderNoteWhereInput
    data: XOR<HotmartOrderNoteUpdateWithoutHotmartAffiliatesInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartAffiliatesInput>
  }

  export type HotmartOrderNoteUpdateWithoutHotmartAffiliatesInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutHotmartAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartOrderNoteCreateWithoutHotmartBuyerInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteCreateOrConnectWithoutHotmartBuyerInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput>
  }

  export type HotmartOrderNoteCreateManyHotmartBuyerInputEnvelope = {
    data: HotmartOrderNoteCreateManyHotmartBuyerInput | HotmartOrderNoteCreateManyHotmartBuyerInput[]
    skipDuplicates?: boolean
  }

  export type HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartBuyerInput = {
    where: HotmartOrderNoteWhereUniqueInput
    update: XOR<HotmartOrderNoteUpdateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartBuyerInput>
    create: XOR<HotmartOrderNoteCreateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedCreateWithoutHotmartBuyerInput>
  }

  export type HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartBuyerInput = {
    where: HotmartOrderNoteWhereUniqueInput
    data: XOR<HotmartOrderNoteUpdateWithoutHotmartBuyerInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartBuyerInput>
  }

  export type HotmartOrderNoteUpdateManyWithWhereWithoutHotmartBuyerInput = {
    where: HotmartOrderNoteScalarWhereInput
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyWithoutHotmartBuyerInput>
  }

  export type HotmartPurchaseCreateWithoutHotmartCommissionsInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseUncheckedCreateWithoutHotmartCommissionsInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseCreateOrConnectWithoutHotmartCommissionsInput = {
    where: HotmartPurchaseWhereUniqueInput
    create: XOR<HotmartPurchaseCreateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedCreateWithoutHotmartCommissionsInput>
  }

  export type HotmartPurchaseUpsertWithoutHotmartCommissionsInput = {
    update: XOR<HotmartPurchaseUpdateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedUpdateWithoutHotmartCommissionsInput>
    create: XOR<HotmartPurchaseCreateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedCreateWithoutHotmartCommissionsInput>
    where?: HotmartPurchaseWhereInput
  }

  export type HotmartPurchaseUpdateToOneWithWhereWithoutHotmartCommissionsInput = {
    where?: HotmartPurchaseWhereInput
    data: XOR<HotmartPurchaseUpdateWithoutHotmartCommissionsInput, HotmartPurchaseUncheckedUpdateWithoutHotmartCommissionsInput>
  }

  export type HotmartPurchaseUpdateWithoutHotmartCommissionsInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPurchaseUncheckedUpdateWithoutHotmartCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartPaymentInfos?: HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPaymentInfosCreateWithoutHotmartPurchaseInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
  }

  export type HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
  }

  export type HotmartPaymentInfosCreateOrConnectWithoutHotmartPurchaseInput = {
    where: HotmartPaymentInfosWhereUniqueInput
    create: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartPaymentInfosCreateManyHotmartPurchaseInputEnvelope = {
    data: HotmartPaymentInfosCreateManyHotmartPurchaseInput | HotmartPaymentInfosCreateManyHotmartPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type HotmartCommissionsCreateWithoutHotmartPurchaseInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartCommissionsCreateOrConnectWithoutHotmartPurchaseInput = {
    where: HotmartCommissionsWhereUniqueInput
    create: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartCommissionsCreateManyHotmartPurchaseInputEnvelope = {
    data: HotmartCommissionsCreateManyHotmartPurchaseInput | HotmartCommissionsCreateManyHotmartPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type HotmartOrderNoteCreateWithoutHotmartPurchaseInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartSubscription?: HotmartSubscriptionCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartSubscriptionId?: number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteCreateOrConnectWithoutHotmartPurchaseInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartOrderNoteCreateManyHotmartPurchaseInputEnvelope = {
    data: HotmartOrderNoteCreateManyHotmartPurchaseInput | HotmartOrderNoteCreateManyHotmartPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type HotmartPaymentInfosUpsertWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartPaymentInfosWhereUniqueInput
    update: XOR<HotmartPaymentInfosUpdateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedUpdateWithoutHotmartPurchaseInput>
    create: XOR<HotmartPaymentInfosCreateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartPaymentInfosUpdateWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartPaymentInfosWhereUniqueInput
    data: XOR<HotmartPaymentInfosUpdateWithoutHotmartPurchaseInput, HotmartPaymentInfosUncheckedUpdateWithoutHotmartPurchaseInput>
  }

  export type HotmartPaymentInfosUpdateManyWithWhereWithoutHotmartPurchaseInput = {
    where: HotmartPaymentInfosScalarWhereInput
    data: XOR<HotmartPaymentInfosUpdateManyMutationInput, HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseInput>
  }

  export type HotmartPaymentInfosScalarWhereInput = {
    AND?: HotmartPaymentInfosScalarWhereInput | HotmartPaymentInfosScalarWhereInput[]
    OR?: HotmartPaymentInfosScalarWhereInput[]
    NOT?: HotmartPaymentInfosScalarWhereInput | HotmartPaymentInfosScalarWhereInput[]
    id?: IntFilter<"HotmartPaymentInfos"> | number
    creationDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    updateDate?: DateTimeFilter<"HotmartPaymentInfos"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    barcode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    billetUrl?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixQRCode?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    pixExpirationDate?: DateTimeNullableFilter<"HotmartPaymentInfos"> | Date | string | null
    type?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    refusalReason?: StringNullableFilter<"HotmartPaymentInfos"> | string | null
    installmentNumbers?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartPaymentInfos"> | number | null
  }

  export type HotmartCommissionsUpsertWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartCommissionsWhereUniqueInput
    update: XOR<HotmartCommissionsUpdateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedUpdateWithoutHotmartPurchaseInput>
    create: XOR<HotmartCommissionsCreateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartCommissionsUpdateWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartCommissionsWhereUniqueInput
    data: XOR<HotmartCommissionsUpdateWithoutHotmartPurchaseInput, HotmartCommissionsUncheckedUpdateWithoutHotmartPurchaseInput>
  }

  export type HotmartCommissionsUpdateManyWithWhereWithoutHotmartPurchaseInput = {
    where: HotmartCommissionsScalarWhereInput
    data: XOR<HotmartCommissionsUpdateManyMutationInput, HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseInput>
  }

  export type HotmartCommissionsScalarWhereInput = {
    AND?: HotmartCommissionsScalarWhereInput | HotmartCommissionsScalarWhereInput[]
    OR?: HotmartCommissionsScalarWhereInput[]
    NOT?: HotmartCommissionsScalarWhereInput | HotmartCommissionsScalarWhereInput[]
    id?: IntFilter<"HotmartCommissions"> | number
    creationDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    updateDate?: DateTimeFilter<"HotmartCommissions"> | Date | string
    deletionDate?: DateTimeNullableFilter<"HotmartCommissions"> | Date | string | null
    sourceName?: StringNullableFilter<"HotmartCommissions"> | string | null
    value?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyValue?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedToCurrency?: StringNullableFilter<"HotmartCommissions"> | string | null
    convertedvalue?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: DecimalNullableFilter<"HotmartCommissions"> | Decimal | DecimalJsLike | number | string | null
    hotmartPurchaseId?: IntNullableFilter<"HotmartCommissions"> | number | null
  }

  export type HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartOrderNoteWhereUniqueInput
    update: XOR<HotmartOrderNoteUpdateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartPurchaseInput>
    create: XOR<HotmartOrderNoteCreateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedCreateWithoutHotmartPurchaseInput>
  }

  export type HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartPurchaseInput = {
    where: HotmartOrderNoteWhereUniqueInput
    data: XOR<HotmartOrderNoteUpdateWithoutHotmartPurchaseInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartPurchaseInput>
  }

  export type HotmartOrderNoteUpdateManyWithWhereWithoutHotmartPurchaseInput = {
    where: HotmartOrderNoteScalarWhereInput
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseInput>
  }

  export type HotmartPurchaseCreateWithoutHotmartPaymentInfosInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartCommissions?: HotmartCommissionsCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseUncheckedCreateWithoutHotmartPaymentInfosInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    orderDate: Date | string
    approvedDate: Date | string
    transactionId: string
    status: string
    fullPriceValue: Decimal | DecimalJsLike | number | string
    fullPriceCurrency: string
    originalPriceValue: Decimal | DecimalJsLike | number | string
    originalPriceCurrency: string
    priceValue: Decimal | DecimalJsLike | number | string
    priceCurrency: string
    offerCode: string
    recurrencyNumber?: number | null
    subscriptionAnticipationPurchase?: boolean | null
    checkoutCountryName: string
    checkoutCountryISO: string
    utmCode?: string | null
    isOrderBump?: boolean | null
    originalTransactionId?: string | null
    nextChargeDate?: Date | string | null
    hotmartCommissions?: HotmartCommissionsUncheckedCreateNestedManyWithoutHotmartPurchaseInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedCreateNestedManyWithoutHotmartPurchaseInput
  }

  export type HotmartPurchaseCreateOrConnectWithoutHotmartPaymentInfosInput = {
    where: HotmartPurchaseWhereUniqueInput
    create: XOR<HotmartPurchaseCreateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedCreateWithoutHotmartPaymentInfosInput>
  }

  export type HotmartPurchaseUpsertWithoutHotmartPaymentInfosInput = {
    update: XOR<HotmartPurchaseUpdateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedUpdateWithoutHotmartPaymentInfosInput>
    create: XOR<HotmartPurchaseCreateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedCreateWithoutHotmartPaymentInfosInput>
    where?: HotmartPurchaseWhereInput
  }

  export type HotmartPurchaseUpdateToOneWithWhereWithoutHotmartPaymentInfosInput = {
    where?: HotmartPurchaseWhereInput
    data: XOR<HotmartPurchaseUpdateWithoutHotmartPaymentInfosInput, HotmartPurchaseUncheckedUpdateWithoutHotmartPaymentInfosInput>
  }

  export type HotmartPurchaseUpdateWithoutHotmartPaymentInfosInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartCommissions?: HotmartCommissionsUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartPurchaseUncheckedUpdateWithoutHotmartPaymentInfosInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fullPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fullPriceCurrency?: StringFieldUpdateOperationsInput | string
    originalPriceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPriceCurrency?: StringFieldUpdateOperationsInput | string
    priceValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceCurrency?: StringFieldUpdateOperationsInput | string
    offerCode?: StringFieldUpdateOperationsInput | string
    recurrencyNumber?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionAnticipationPurchase?: NullableBoolFieldUpdateOperationsInput | boolean | null
    checkoutCountryName?: StringFieldUpdateOperationsInput | string
    checkoutCountryISO?: StringFieldUpdateOperationsInput | string
    utmCode?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderBump?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    nextChargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartCommissions?: HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
    HotmartOrderNote?: HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseNestedInput
  }

  export type HotmartOrderNoteCreateWithoutHotmartSubscriptionInput = {
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    producerName?: string | null
    externalWebhookHotmartReceiver: ExternalWebhookHotmartReceiverCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartProduct: HotmartProductCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartAffiliates?: HotmartAffiliatesCreateNestedManyWithoutHotmartOrderNoteInput
    hotmartBuyer: HotmartBuyerCreateNestedOneWithoutHotmartOrderNoteInput
    hotmartPurchase: HotmartPurchaseCreateNestedOneWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartAffiliates?: HotmartAffiliatesUncheckedCreateNestedManyWithoutHotmartOrderNoteInput
  }

  export type HotmartOrderNoteCreateOrConnectWithoutHotmartSubscriptionInput = {
    where: HotmartOrderNoteWhereUniqueInput
    create: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput>
  }

  export type HotmartOrderNoteCreateManyHotmartSubscriptionInputEnvelope = {
    data: HotmartOrderNoteCreateManyHotmartSubscriptionInput | HotmartOrderNoteCreateManyHotmartSubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type HotmartOrderNoteUpsertWithWhereUniqueWithoutHotmartSubscriptionInput = {
    where: HotmartOrderNoteWhereUniqueInput
    update: XOR<HotmartOrderNoteUpdateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartSubscriptionInput>
    create: XOR<HotmartOrderNoteCreateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedCreateWithoutHotmartSubscriptionInput>
  }

  export type HotmartOrderNoteUpdateWithWhereUniqueWithoutHotmartSubscriptionInput = {
    where: HotmartOrderNoteWhereUniqueInput
    data: XOR<HotmartOrderNoteUpdateWithoutHotmartSubscriptionInput, HotmartOrderNoteUncheckedUpdateWithoutHotmartSubscriptionInput>
  }

  export type HotmartOrderNoteUpdateManyWithWhereWithoutHotmartSubscriptionInput = {
    where: HotmartOrderNoteScalarWhereInput
    data: XOR<HotmartOrderNoteUpdateManyMutationInput, HotmartOrderNoteUncheckedUpdateManyWithoutHotmartSubscriptionInput>
  }

  export type HotmartOrderNoteCreateManyExternalWebhookHotmartReceiverInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
  }

  export type HotmartOrderNoteUpdateWithoutExternalWebhookHotmartReceiverInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutExternalWebhookHotmartReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutExternalWebhookHotmartReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartAffiliatesCreateManyHotmartOrderNoteInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    lastOrderDate?: Date | string | null
    affiliateCode?: string | null
    affiliateName?: string | null
  }

  export type HotmartAffiliatesUpdateWithoutHotmartOrderNoteInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartAffiliatesUncheckedUpdateWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOrderDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateCode?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotmartOrderNoteCreateManyHotmartProductInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
  }

  export type HotmartOrderNoteUpdateWithoutHotmartProductInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutHotmartProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartOrderNoteCreateManyHotmartBuyerInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    producerName?: string | null
    hotmartPurchaseId: number
    hotmartSubscriptionId?: number | null
  }

  export type HotmartOrderNoteUpdateWithoutHotmartBuyerInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutHotmartBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartBuyerInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPaymentInfosCreateManyHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    barcode?: string | null
    billetUrl?: string | null
    pixCode?: string | null
    pixQRCode?: string | null
    pixExpirationDate?: Date | string | null
    type?: string | null
    refusalReason?: string | null
    installmentNumbers?: number | null
  }

  export type HotmartCommissionsCreateManyHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    sourceName?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    currencyValue?: string | null
    convertedToCurrency?: string | null
    convertedvalue?: Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartOrderNoteCreateManyHotmartPurchaseInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartSubscriptionId?: number | null
  }

  export type HotmartPaymentInfosUpdateWithoutHotmartPurchaseInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPaymentInfosUncheckedUpdateWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartPaymentInfosUncheckedUpdateManyWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    billetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pixCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixQRCode?: NullableStringFieldUpdateOperationsInput | string | null
    pixExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    refusalReason?: NullableStringFieldUpdateOperationsInput | string | null
    installmentNumbers?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartCommissionsUpdateWithoutHotmartPurchaseInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartCommissionsUncheckedUpdateWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartCommissionsUncheckedUpdateManyWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyValue?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    convertedvalue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyConvertionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type HotmartOrderNoteUpdateWithoutHotmartPurchaseInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartSubscription?: HotmartSubscriptionUpdateOneWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartSubscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotmartOrderNoteCreateManyHotmartSubscriptionInput = {
    id?: number
    creationDate?: Date | string
    updateDate?: Date | string
    deletionDate?: Date | string | null
    externalWebhookHotmartReceiverId: number
    hotmartProductId: number
    hotmartBuyerId: number
    producerName?: string | null
    hotmartPurchaseId: number
  }

  export type HotmartOrderNoteUpdateWithoutHotmartSubscriptionInput = {
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    externalWebhookHotmartReceiver?: ExternalWebhookHotmartReceiverUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartProduct?: HotmartProductUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartAffiliates?: HotmartAffiliatesUpdateManyWithoutHotmartOrderNoteNestedInput
    hotmartBuyer?: HotmartBuyerUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
    hotmartPurchase?: HotmartPurchaseUpdateOneRequiredWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateWithoutHotmartSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
    hotmartAffiliates?: HotmartAffiliatesUncheckedUpdateManyWithoutHotmartOrderNoteNestedInput
  }

  export type HotmartOrderNoteUncheckedUpdateManyWithoutHotmartSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalWebhookHotmartReceiverId?: IntFieldUpdateOperationsInput | number
    hotmartProductId?: IntFieldUpdateOperationsInput | number
    hotmartBuyerId?: IntFieldUpdateOperationsInput | number
    producerName?: NullableStringFieldUpdateOperationsInput | string | null
    hotmartPurchaseId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ExternalWebhookHotmartReceiverCountOutputTypeDefaultArgs instead
     */
    export type ExternalWebhookHotmartReceiverCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalWebhookHotmartReceiverCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartOrderNoteCountOutputTypeDefaultArgs instead
     */
    export type HotmartOrderNoteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartOrderNoteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartProductCountOutputTypeDefaultArgs instead
     */
    export type HotmartProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartBuyerCountOutputTypeDefaultArgs instead
     */
    export type HotmartBuyerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartBuyerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartPurchaseCountOutputTypeDefaultArgs instead
     */
    export type HotmartPurchaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartPurchaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type HotmartSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalWebhookHotmartReceiverDefaultArgs instead
     */
    export type ExternalWebhookHotmartReceiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalWebhookHotmartReceiverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartOrderNoteDefaultArgs instead
     */
    export type HotmartOrderNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartOrderNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartProductDefaultArgs instead
     */
    export type HotmartProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartAffiliatesDefaultArgs instead
     */
    export type HotmartAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartAffiliatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartBuyerDefaultArgs instead
     */
    export type HotmartBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartBuyerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartCommissionsDefaultArgs instead
     */
    export type HotmartCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartCommissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartPurchaseDefaultArgs instead
     */
    export type HotmartPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartPurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartPaymentInfosDefaultArgs instead
     */
    export type HotmartPaymentInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartPaymentInfosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotmartSubscriptionDefaultArgs instead
     */
    export type HotmartSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotmartSubscriptionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}